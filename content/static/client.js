(
function imploderLoader(defs, params, evl) {
    "use strict";
    var req = typeof (require) !== "undefined" ? require : function () { throw new Error("External require() function is not defined! Could not load any external module."); };
    function handleError(e, action) {
        var handler = params.errorHandler;
        if (handler) {
            handler(e, action);
        }
        else {
            console.error((action ? "Error during " + action + ": " : "") + (e.stack || e.message || e));
        }
        throw e;
    }
    // разбираем полученный массив определений
    var renames = {};
    var defMap = {};
    for (var i = 0; i < defs.length; i++) {
        var v = defs[i];
        var m = typeof (v[2]) !== "string" ? v[2] : undefined;
        var def = m ? m : {};
        def.name = v[0];
        def.code = v[v.length - 1];
        if (m && m.altName) {
            renames[m.altName] = def.name;
        }
        def.dependencies = Array.isArray(v[1]) ? v[1] : [];
        defMap[def.name] = def;
    }
    var amd = typeof (define) === "function" && !!define.amd;
    /** функция, которую будут дергать в качестве require изнутри модулей */
    function requireAny(names, onOk, onError) {
        if (!onOk) {
            // дернуты как commonjs, т.е. синхронно с одним именем
            var name_1 = names;
            if (name_1 in defMap) {
                return getProduct(name_1);
            }
            else {
                // тут мы просто надеемся, что человек, который пишет код - не дурак
                // и знает, в каком окружении он будет запускаться
                // и поэтому просто дергаем require как commonjs синхронный require
                return req(name_1);
            }
        }
        else {
            // дернуты как amd
            var callError = function (e) {
                if (onError) {
                    onError(e);
                }
                else {
                    handleError(e);
                }
            };
            try {
                var nameArr = Array.isArray(names) ? names : [names];
                var resultArr_1 = [];
                var nameIndex_1 = {};
                var externalNameArr_1 = nameArr.filter(function (name, index) {
                    nameIndex_1[name] = index;
                    if (name in defMap) {
                        resultArr_1[index] = getProduct(name);
                        return false;
                    }
                    return true;
                });
                if (externalNameArr_1.length === 0) {
                    return onOk.apply(null, resultArr_1);
                }
                else {
                    if (amd) {
                        return req(externalNameArr_1, function (externalResults) {
                            for (var i = 0; i < externalNameArr_1.length; i++) {
                                resultArr_1[nameIndex_1[externalNameArr_1[i]]] = externalResults[i];
                            }
                            onOk.apply(null, resultArr_1);
                        }, onError);
                    }
                    else {
                        // если у нас запросили модули асинхронно, но при этом у нас есть только синрохнный commonjs-овый require - 
                        // то используем его, чего еще делать
                        externalNameArr_1.forEach(function (name) { return resultArr_1[nameIndex_1[name]] = req(name); });
                        onOk.apply(null, resultArr_1);
                    }
                }
            }
            catch (e) {
                callError(e);
            }
        }
    }
    var currentlyDefiningProductMap = {};
    var currentlyDefiningProductSeq = [];
    var products = {};
    function throwCircularDependencyError(name) {
        var str = name;
        for (var i = currentlyDefiningProductSeq.length - 1; i >= 0; i--) {
            var n = currentlyDefiningProductSeq[i];
            str += " <- " + currentlyDefiningProductSeq[i];
            if (n === name)
                break;
        }
        throw new Error("Unresolvable circular dependency detected: " + str);
    }
    function getProduct(name) {
        name = renames[name] || name;
        var meta = defMap[name];
        if (!(name in products)) {
            if (name in currentlyDefiningProductMap) {
                throwCircularDependencyError(name);
            }
            currentlyDefiningProductMap[name] = true;
            currentlyDefiningProductSeq.push(name);
            try {
                var product = {};
                var deps_1 = [product, requireAny];
                meta.dependencies.forEach(function (name) {
                    if (name in renames) {
                        name = renames[name];
                    }
                    var product = products[name];
                    if (product) {
                        deps_1.push(product);
                        return;
                    }
                    var depMeta = defMap[name];
                    if (!depMeta) {
                        throw new Error("Failed to get module \"" + name + "\": no definition is known and no preloaded external module is present.");
                    }
                    deps_1.push(depMeta.arbitraryType || (!depMeta.exports && !depMeta.exportRefs) ? getProduct(name) : getProxy(depMeta));
                });
                var fullCode = meta.code;
                if (meta.nonModule) {
                    fullCode = "function(){" + fullCode + "}";
                }
                fullCode = "'use strict';(" + fullCode + ")\n//# sourceURL=" + meta.name;
                var defFunc = evl(fullCode);
                var returnProduct = defFunc.apply(null, deps_1);
                if (meta.arbitraryType) {
                    product = returnProduct;
                }
                products[name] = product;
            }
            finally {
                delete currentlyDefiningProductMap[name];
                currentlyDefiningProductSeq.pop();
            }
        }
        return products[name];
    }
    var proxies = {};
    function getProxy(def) {
        if (!(def.name in proxies)) {
            var proxy_1 = {};
            getAllExportNames(def).forEach(function (arr) {
                arr.forEach(function (name) {
                    defineProxyProp(def, proxy_1, name);
                });
            });
            proxies[def.name] = proxy_1;
        }
        return proxies[def.name];
    }
    function getAllExportNames(meta, result, noDefault) {
        if (result === void 0) { result = []; }
        if (noDefault === void 0) { noDefault = false; }
        if (meta.exports) {
            if (noDefault) {
                result.push(meta.exports.filter(function (_) { return _ !== "default"; }));
            }
            else {
                result.push(meta.exports);
            }
        }
        if (meta.exportRefs) {
            meta.exportRefs.forEach(function (ref) {
                // тут, теоретически, могла бы возникнуть бесконечная рекурсия
                // но не возникнет, еще при компиляции есть проверка
                if (ref in defMap) {
                    getAllExportNames(defMap[ref], result, true);
                }
                else if (ref in products) {
                    // модуля может не быть, если он внешний и в бандл не вошел
                    result.push(Object.keys(products[ref]));
                }
                else {
                    // такого по идее произойти не должно никогда, т.к. оно упадет раньше
                    // еще на этапе подгрузки внешних модулей
                    throw new Error("External module " + ref + " is not loaded at required time.");
                }
            });
        }
        return result;
    }
    function defineProxyProp(meta, proxy, name) {
        if (proxy.hasOwnProperty(name)) {
            return;
        }
        Object.defineProperty(proxy, name, {
            get: function () { return getProduct(meta.name)[name]; },
            set: function (v) { return getProduct(meta.name)[name] = v; },
            enumerable: true
        });
    }
    function discoverExternalModules(moduleName, result, visited) {
        if (result === void 0) { result = []; }
        if (visited === void 0) { visited = {}; }
        if (moduleName in renames) {
            moduleName = renames[moduleName];
        }
        if (!(moduleName in visited)) {
            visited[moduleName] = true;
            if (moduleName in defMap) {
                defMap[moduleName].dependencies.forEach(function (depName) { return discoverExternalModules(depName, result, visited); });
            }
            else {
                result.push(moduleName);
            }
        }
        return result;
    }
    function afterExternalsLoaded() {
        var mainProduct = getProduct(params.entryPoint.module);
        // инициализируем все модули в бандле, ради сайд-эффектов
        Object.keys(defMap).forEach(function (name) {
            if (!(name in products)) {
                getProduct(name);
            }
        });
        var err = null;
        if (params.entryPoint.function) {
            try {
                mainProduct[params.entryPoint.function].apply(null, params.entryPointArgs || []);
            }
            catch (e) {
                err = e;
            }
        }
        if (err) {
            handleError(err);
        }
        if (typeof (module) === "object" && module.exports) {
            module.exports = mainProduct;
        }
        return mainProduct;
    }
    function start() {
        if (amd) {
            var externalModuleNames_1 = discoverExternalModules(params.entryPoint.module, ["require"]);
            define(externalModuleNames_1, function (require) {
                req = require;
                for (var i = externalModuleNames_1.length; i < arguments.length; i++) {
                    products[externalModuleNames_1[i]] = arguments[i];
                }
                return afterExternalsLoaded();
            });
        }
        else {
            var externalModuleNames_2 = discoverExternalModules(params.entryPoint.module);
            requireAny(externalModuleNames_2, function () {
                for (var i = 0; i < arguments.length; i++) {
                    products[externalModuleNames_2[i]] = arguments[i];
                }
                afterExternalsLoaded();
            });
        }
    }
    start();
})(

[["/client/api_client",["/common/utils"],"function (exports, require, utils_1) {\n    const viewSettingsFilename = \"view_settings.json\";\n    const buildingPlanFilename = \"building_plan.json\";\n    class ApiClient {\n        constructor(apiUrlBase) {\n            this.apiUrlBase = apiUrlBase;\n        }\n        async callApi(name, body = null) {\n            let resp = await fetch(this.apiUrlBase + name, {\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                method: \"POST\",\n                body: JSON.stringify(body)\n            });\n            let result = await resp.json();\n            if (result.ok !== true) {\n                throw new Error(\"Response is not OK\");\n            }\n            return result.result;\n        }\n        async getJson(path) {\n            let resp = await fetch(\"./static/\" + path, { method: \"GET\" });\n            return await resp.json();\n        }\n        saveSettings(filename, settings) {\n            return this.callApi(\"saveSettings\", [filename, settings]);\n        }\n        saveViewSettings(settings) {\n            return this.saveSettings(viewSettingsFilename, settings);\n        }\n        async loadViewSettings() {\n            try {\n                return await this.getJson(viewSettingsFilename);\n            }\n            catch (e) {\n                (0, utils_1.logWarn)(\"Failed to load view settings: \", e);\n                return null;\n            }\n        }\n        saveBuildingPlan(settings) {\n            return this.saveSettings(buildingPlanFilename, settings);\n        }\n        async loadBuildingPlan() {\n            try {\n                return await this.getJson(buildingPlanFilename);\n            }\n            catch (e) {\n                (0, utils_1.logWarn)(\"Failed to load building plan: \", e);\n                return null;\n            }\n        }\n        enumeratePanoramFiles() {\n            return this.callApi(\"enumeratePanoramFiles\");\n        }\n        async canEdit() {\n            try {\n                return this.callApi(\"canEdit\");\n            }\n            catch (e) {\n                (0, utils_1.logWarn)(\"Got error trying to determine if I am allowed to edit. Guess not. \", e);\n                return false;\n            }\n        }\n    }\n    exports.ApiClient = ApiClient;\n}\n"],["/client/app_state",["/client/boundable/boundable"],"function (exports, require, boundable_1) {\n    class AppState {\n        constructor() {\n            this.isPlanActive = (0, boundable_1.boundValue)(false);\n            this.isInEditMode = (0, boundable_1.boundValue)(false);\n            this.selectedFloor = (0, boundable_1.boundValue)(null);\n            this.selectedImage = (0, boundable_1.boundValue)(null);\n            this.hideInactiveFloors = (0, boundable_1.boundValue)(false);\n            this.panoramFsTree = (0, boundable_1.boundValue)([]);\n            this.selectedSceneObject = (0, boundable_1.boundValue)(null);\n        }\n    }\n    exports.AppState = AppState;\n}\n"],["/client/boundable/boundable","function (exports, require) {\n    function isBoundable(x) {\n        return typeof (x) === \"function\" && (!!x.isBoundValue || !!x.isBoundComputable);\n    }\n    exports.isBoundable = isBoundable;\n    function isBoundValue(x) {\n        return typeof (x) === \"function\" && !!x.isBoundValue;\n    }\n    exports.isBoundValue = isBoundValue;\n    function unwrapBoundable(x) {\n        return isBoundable(x) ? x() : x;\n    }\n    exports.unwrapBoundable = unwrapBoundable;\n    function createSubscribeNotify(getValue) {\n        let subscribers = new Set();\n        return {\n            subscribe: (listener) => {\n                let v = getValue();\n                let sub = { fn: listener, lastKnownValue: v };\n                subscribers.add(sub);\n                return () => subscribers.delete(sub);\n            },\n            notify: () => {\n                let subs = [...subscribers];\n                for (let i = 0; i < subs.length; i++) {\n                    let sub = subs[i];\n                    let v = getValue();\n                    let hasDiff = boundableContentCanBeDifferent(v, sub.lastKnownValue);\n                    sub.lastKnownValue = v;\n                    if (hasDiff) {\n                        sub.fn(v);\n                    }\n                }\n            },\n            subscribers: subscribers\n        };\n    }\n    const notificationStack = [];\n    function withAccessNotifications(action, onAccess) {\n        notificationStack.push(onAccess);\n        let result;\n        try {\n            result = action();\n        }\n        finally {\n            notificationStack.pop();\n        }\n        return result;\n    }\n    function notifyOnAccess(v) {\n        if (notificationStack.length > 0) {\n            notificationStack[notificationStack.length - 1](v);\n        }\n    }\n    function boundableContentCanBeDifferent(oldValue, newValue) {\n        return newValue !== oldValue || (typeof (oldValue) === \"object\" && oldValue !== null);\n    }\n    exports.boundableContentCanBeDifferent = boundableContentCanBeDifferent;\n    function boundValue(x) {\n        let value = x;\n        let getterSetter = function (newValue) {\n            if (arguments.length < 1) {\n                notifyOnAccess(result);\n            }\n            else if (boundableContentCanBeDifferent(value, newValue)) {\n                value = newValue;\n                result.notify();\n            }\n            return value;\n        };\n        let { subscribe, notify } = createSubscribeNotify(() => value);\n        let result = Object.assign(getterSetter, {\n            isBoundValue: true,\n            subscribe: subscribe,\n            notify: notify\n        });\n        return result;\n    }\n    exports.boundValue = boundValue;\n    function computable(computingFn) {\n        let hasComputedValue = false;\n        let value = null;\n        let subDisposers = [];\n        let subDispose = () => {\n            subDisposers.forEach(x => x());\n            subDisposers.length = 0;\n        };\n        let forceRecalculate = () => {\n            hasComputedValue = false;\n            if (subscribers.size !== 0) {\n                computeAndSubscribe();\n            }\n        };\n        let computeAndSubscribe = () => {\n            subDispose();\n            let valuesAccessed = new Set();\n            let newValue = withAccessNotifications(computingFn, boundValue => valuesAccessed.add(boundValue));\n            valuesAccessed.forEach(v => subDisposers.push(v.subscribe(forceRecalculate)));\n            let hasDiff = !hasComputedValue || boundableContentCanBeDifferent(value, newValue);\n            hasComputedValue = true;\n            value = newValue;\n            if (hasDiff) {\n                computable.notify();\n            }\n            return value;\n        };\n        let maybeUnsubscribeFromValues = () => {\n            if (subscribers.size === 0) {\n                hasComputedValue = false;\n                value = null;\n                subDispose();\n            }\n        };\n        let computableFn = () => {\n            notifyOnAccess(computable);\n            if (subscribers.size === 0) {\n                return computingFn();\n            }\n            if (!hasComputedValue) {\n                return computeAndSubscribe();\n            }\n            return value;\n        };\n        let { subscribe, notify, subscribers } = createSubscribeNotify(computableFn);\n        let wrappedSubscribe = (listener) => {\n            if (!hasComputedValue) {\n                computeAndSubscribe();\n            }\n            let disposer = subscribe(listener);\n            return () => {\n                disposer();\n                maybeUnsubscribeFromValues();\n            };\n        };\n        let computable = Object.assign(computableFn, {\n            isBoundComputable: true,\n            subscribe: wrappedSubscribe,\n            notify: notify\n        });\n        return computable;\n    }\n    exports.computable = computable;\n}\n"],["/client/client_entrypoint",["/client/utils/graphic_utils","/client/skybox_controller","/client/context","/client/settings_controller","/client/api_client","/client/planbox_controller","/client/layout_controller","/client/app_state"],"function (exports, require, graphic_utils_1, skybox_controller_1, context_1, settings_controller_1, api_client_1, planbox_controller_1, layout_controller_1, app_state_1) {\n    async function main() {\n        checkWebglVersion(1);\n        let context = new context_1.AppContextImpl();\n        context.api = new api_client_1.ApiClient(\"/api/\");\n        context.state = new app_state_1.AppState();\n        let [viewSettings, plan, canEdit] = await Promise.all([\n            context.api.loadViewSettings(),\n            context.api.loadBuildingPlan(),\n            context.api.canEdit()\n        ]);\n        context.settings = new settings_controller_1.SettingsController(viewSettings, plan, context);\n        context.planbox = new planbox_controller_1.PlanboxController(context);\n        context.skybox = new skybox_controller_1.SkyboxController(context.settings, context);\n        context.layout = new layout_controller_1.LayoutController(context, { canEdit, root: document.body });\n        context.layout.start();\n    }\n    exports.main = main;\n    function checkWebglVersion(version) {\n        if ((0, graphic_utils_1.isWebGLAvailable)(version)) {\n            return;\n        }\n        let container = document.getElementById(\"loading-screen\");\n        if (container) {\n            container.appendChild((0, graphic_utils_1.getWebglErrorElement)(version));\n        }\n        throw new Error(\"No webGL, aborted\");\n    }\n}\n"],["/client/context","function (exports, require) {\n    const emptyAppContext = {\n        skybox: null,\n        planbox: null,\n        settings: null,\n        state: null,\n        api: null,\n        layout: null\n    };\n    function wrapWithGetterSetters(names) {\n        let result = class WrappedWithGettersSetters {\n            constructor() {\n                names.forEach(name => {\n                    let value = null;\n                    Object.defineProperty(this, name, {\n                        get: () => {\n                            if (value === null) {\n                                throw new Error(\"No \" + name + \" is defined yet.\");\n                            }\n                            else {\n                                return value;\n                            }\n                        },\n                        set: newValue => {\n                            value = newValue;\n                        }\n                    });\n                });\n            }\n        };\n        return result;\n    }\n    class AppContextImpl extends wrapWithGetterSetters(Object.keys(emptyAppContext)) {\n    }\n    exports.AppContextImpl = AppContextImpl;\n}\n"],["/client/controls/common/button",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1) {\n    function button(options) {\n        let button = (0, dom_utils_1.tag)({});\n        let watch = (0, control_1.makeNodeBoundWatcher)(button);\n        function recalcClass() {\n            button.className = \"button \" + ((0, boundable_1.unwrapBoundable)(options.class) || \"\") + \" \" + ((0, boundable_1.unwrapBoundable)(options.disabled) ? \"disabled\" : \"\");\n        }\n        watch(options.class, recalcClass);\n        watch(options.disabled, recalcClass);\n        watch(options.text, text => button.textContent = text);\n        let isRunning = false;\n        button.addEventListener(\"click\", async () => {\n            if (isRunning) {\n                return;\n            }\n            isRunning = true;\n            try {\n                await Promise.resolve(options.onclick.call(null));\n            }\n            finally {\n                isRunning = false;\n            }\n        });\n        return { element: button };\n    }\n    exports.button = button;\n}\n"],["/client/controls/common/collapser",["/client/controls/control","/client/utils/dom_utils"],"function (exports, require, control_1, dom_utils_1) {\n    function collapser(options, children) {\n        let header = (0, dom_utils_1.tag)({ class: \"collapser-header\" });\n        let collapser = (0, dom_utils_1.tag)({ class: \"collapser\" }, [header]);\n        let collapsed = true;\n        function updateText() {\n            header.textContent = options.text + \" \" + (collapsed ? \"v\" : \"^\");\n        }\n        header.addEventListener(\"click\", () => {\n            collapsed = !collapsed;\n            if (collapsed) {\n                let childNodes = collapser.childNodes;\n                for (let i = childNodes.length - 1; i >= 0; i--) {\n                    let node = childNodes[i];\n                    if (node !== header) {\n                        node.remove();\n                    }\n                }\n            }\n            else {\n                children.forEach(child => {\n                    let el = (0, dom_utils_1.toHtmlTag)(child);\n                    if (el) {\n                        collapser.appendChild(el);\n                    }\n                });\n            }\n            updateText();\n        });\n        let watch = (0, control_1.makeNodeBoundWatcher)(collapser);\n        watch(options.text, updateText);\n        return collapser;\n    }\n    exports.collapser = collapser;\n}\n"],["/client/controls/common/drop_down_list",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1) {\n    function dropDownList(options) {\n        let select = (0, dom_utils_1.tag)({ tagName: \"select\" });\n        let value = (0, boundable_1.isBoundValue)(options.value) ? options.value : (0, boundable_1.boundValue)(options.value);\n        let watch = (0, control_1.makeNodeBoundWatcher)(select);\n        watch(options.options, newOptValues => {\n            let oldValue = value();\n            select.innerHTML = \"\";\n            let hasValue = false;\n            newOptValues.forEach(option => {\n                hasValue = hasValue || option.value === oldValue;\n                select.appendChild((0, dom_utils_1.tag)({ tagName: \"option\", text: option.label, value: option.value }));\n            });\n            if (hasValue && oldValue !== null) {\n                select.value = oldValue;\n            }\n            else if (newOptValues.length > 0) {\n                select.value = newOptValues[0].value;\n                value(newOptValues[0].value);\n            }\n            else if (oldValue !== null) {\n                select.value = \"\";\n                value(null);\n            }\n        });\n        watch(value, newValue => {\n            select.value = newValue !== null ? newValue : \"\";\n        });\n        select.addEventListener(\"change\", () => value(select.value));\n        return { element: select };\n    }\n    exports.dropDownList = dropDownList;\n}\n"],["/client/controls/common/number_input",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils","/client/utils/number_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1, number_utils_1) {\n    function numberInput(opts) {\n        let optsValue = opts.value || (0, boundable_1.boundValue)(0);\n        let input = (0, dom_utils_1.tag)({\n            tagName: \"input\",\n            type: \"number\",\n            class: \"number-input\"\n        });\n        function getNestedBoundValue() {\n            let nestedValue = optsValue();\n            return (0, boundable_1.isBoundValue)(nestedValue) ? nestedValue : optsValue;\n        }\n        let lastKnownValue = input.value;\n        function onMaybeChange() {\n            if (input.value === lastKnownValue) {\n                return;\n            }\n            lastKnownValue = input.value;\n            let boundValue = getNestedBoundValue();\n            boundValue(parseFloat(input.value));\n        }\n        input.addEventListener(\"change\", onMaybeChange);\n        input.addEventListener(\"keypress\", onMaybeChange);\n        input.addEventListener(\"keydown\", onMaybeChange);\n        input.addEventListener(\"keyup\", onMaybeChange);\n        let watch = (0, control_1.makeNodeBoundWatcher)(input);\n        let onNestedValueChanged = (value) => {\n            input.value = (0, number_utils_1.toFixedNoTrail)(value, 5);\n        };\n        {\n            let nestedValue = optsValue();\n            if ((0, boundable_1.isBoundValue)(nestedValue)) {\n                let clearNestedWatcher = null;\n                watch(optsValue, nestedValue => {\n                    if (clearNestedWatcher) {\n                        clearNestedWatcher();\n                    }\n                    clearNestedWatcher = watch(nestedValue, onNestedValueChanged);\n                });\n            }\n            else {\n                if (!(0, boundable_1.isBoundValue)(optsValue)) {\n                    throw new Error(\"WUT\");\n                }\n                watch(optsValue, onNestedValueChanged);\n            }\n        }\n        watch(opts.disabled, disabled => {\n            input.disabled = disabled;\n        });\n        return {\n            element: input,\n            get value() {\n                return getNestedBoundValue();\n            }\n        };\n    }\n    exports.numberInput = numberInput;\n}\n"],["/client/controls/common/panel",["/client/controls/control","/client/utils/dom_utils"],"function (exports, require, control_1, dom_utils_1) {\n    function panel(opts, children = []) {\n        let hidden = opts.hidden;\n        delete opts.hidden;\n        let panel = (0, dom_utils_1.tag)(opts, children);\n        let watch = (0, control_1.makeNodeBoundWatcher)(panel, { preventDisplayChange: true });\n        watch(hidden, hidden => {\n            panel.style.display = hidden ? \"none\" : \"\";\n        });\n        return panel;\n    }\n    exports.panel = panel;\n}\n"],["/client/controls/common/slider",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils","/client/utils/drag","/client/utils/number_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1, drag_1, number_utils_1) {\n    function slider(options) {\n        let toFixed = (x) => (0, number_utils_1.toFixedNoTrail)(x, options.fractionalPositions || 5);\n        let valueContainer = (0, boundable_1.isBoundValue)(options.value) ? options.value : (0, boundable_1.boundValue)(options.value);\n        let input = (0, dom_utils_1.tag)({ tagName: \"input\", type: \"number\" });\n        input.value = toFixed(valueContainer());\n        let notch = (0, dom_utils_1.tag)({ class: \"slider-notch\", style: \"left: 0\" });\n        let notchContainer = (0, dom_utils_1.tag)({ class: \"slider-notch-container\" }, [notch]);\n        let dragging = false;\n        let oldValue = input.value;\n        function onInputMaybeChanged() {\n            if (dragging) {\n                oldValue = input.value;\n                return;\n            }\n            if (oldValue === input.value) {\n                return;\n            }\n            oldValue = input.value;\n            let value = Math.max(options.min, Math.min(options.max, parseFloat(input.value)));\n            if (options.integer) {\n                value = Math.round(value);\n            }\n            valueContainer(value);\n        }\n        function setNotchPos(value) {\n            notch.style.left = (((value - options.min) / (options.max - options.min)) * 100) + \"%\";\n        }\n        setNotchPos(valueContainer());\n        function setInputValue(value) {\n            if (options.integer) {\n                value = Math.round(value);\n            }\n            input.value = toFixed(value);\n        }\n        input.addEventListener(\"change\", onInputMaybeChanged, { passive: true });\n        input.addEventListener(\"keyup\", onInputMaybeChanged, { passive: true });\n        input.addEventListener(\"keypress\", onInputMaybeChanged, { passive: true });\n        input.addEventListener(\"mouseup\", onInputMaybeChanged, { passive: true });\n        input.addEventListener(\"click\", onInputMaybeChanged, { passive: true });\n        let minX = 0, maxX = 0;\n        (0, drag_1.addDragListeners)({\n            element: notch,\n            onDragStart: () => {\n                let rect = notchContainer.getBoundingClientRect();\n                minX = rect.left;\n                maxX = rect.right;\n                dragging = true;\n            },\n            onDragEnd: () => {\n                dragging = false;\n            },\n            onDrag: ({ x }) => {\n                let percent = Math.max(0, Math.min(1, (x - minX) / (maxX - minX)));\n                let value = options.min + ((options.max - options.min) * percent);\n                valueContainer(value);\n            }\n        });\n        let el = (0, dom_utils_1.tag)({ class: \"slider\" }, [\n            (0, dom_utils_1.tag)({ class: \"slider-top\" }, [\n                (0, dom_utils_1.tag)({ class: \"editor label\", text: options.label }),\n                input,\n                (0, dom_utils_1.tag)({ class: \"slider-units\", text: options.units || \"\" }),\n            ]),\n            (0, dom_utils_1.tag)({ class: \"slider-bottom\" }, [\n                (0, dom_utils_1.tag)({ class: \"slider-min\", text: toFixed(options.min) }),\n                (0, dom_utils_1.tag)({ class: \"slider-notch-container-container\" }, [\n                    notchContainer\n                ]),\n                (0, dom_utils_1.tag)({ class: \"slider-max\", text: toFixed(options.max) })\n            ])\n        ]);\n        let watch = (0, control_1.makeNodeBoundWatcher)(el);\n        watch(valueContainer, newValue => {\n            setNotchPos(newValue);\n            if (input.value !== toFixed(newValue)) {\n                setInputValue(newValue);\n            }\n        });\n        return {\n            element: el,\n            value: valueContainer\n        };\n    }\n    exports.slider = slider;\n}\n"],["/client/controls/common/tree_list",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1) {\n    function treeList(options) {\n        let treeListRoot = (0, dom_utils_1.tag)({ class: \"tree-list\" });\n        let itemsByValue = new Map();\n        let value = (0, boundable_1.isBoundValue)(options.value) ? options.value : (0, boundable_1.boundValue)(options.value);\n        function renderItem(item) {\n            let el = (0, dom_utils_1.tag)({\n                class: [\n                    \"tree-list-item\",\n                    item.items ? \"has-children collapsed\" : null,\n                ],\n                text: item.label,\n                style: `margin-left: ${item.depth}em`,\n                \"data-depth\": item.depth\n            });\n            function tryToggleExpanded() {\n                if (item.items) {\n                    el.classList.toggle(\"collapsed\");\n                    el.classList.toggle(\"expanded\");\n                    if (result.expanded) {\n                        while (true) {\n                            let next = el.nextElementSibling;\n                            if (!next) {\n                                break;\n                            }\n                            let depth = parseInt(next.getAttribute(\"data-depth\") || \"0\");\n                            if (depth <= (item.depth || 0)) {\n                                break;\n                            }\n                            next.remove();\n                        }\n                    }\n                    else {\n                        let lastAddedElem = el;\n                        let addAll = (items) => {\n                            items.forEach(item => {\n                                let el = item.element = (item.element || renderItem(item));\n                                lastAddedElem.after(el.element);\n                                lastAddedElem = el.element;\n                                if (item.items && el.expanded) {\n                                    addAll(item.items);\n                                }\n                            });\n                        };\n                        addAll(item.items);\n                    }\n                    result.expanded = !result.expanded;\n                }\n            }\n            el.addEventListener(\"click\", () => {\n                tryToggleExpanded();\n                if (item.value !== undefined) {\n                    value(value() === item.value ? null : item.value);\n                }\n            }, { passive: true });\n            let result = {\n                expanded: false,\n                element: el,\n                toggleExpanded: tryToggleExpanded\n            };\n            return result;\n        }\n        function setItems(newItems) {\n            value(null);\n            treeListRoot.innerHTML = \"\";\n            itemsByValue = new Map();\n            let visit = (newItems, parent, depth = 0) => {\n                newItems.forEach(item => {\n                    item.parent = parent;\n                    item.depth = depth;\n                    if (item.value) {\n                        itemsByValue.set(item.value, item);\n                    }\n                    if (item.items) {\n                        visit(item.items, parent, depth + 1);\n                    }\n                });\n            };\n            visit(newItems);\n            newItems.forEach((item) => {\n                let el = item.element = (item.element || renderItem(item));\n                treeListRoot.appendChild(el.element);\n            });\n        }\n        function chainExpand(item) {\n            if (item.parent) {\n                chainExpand(item.parent);\n            }\n            if (!item.items || !item.element || item.element.expanded) {\n                return;\n            }\n            item.element.toggleExpanded();\n        }\n        function toggleSelectionOn(value) {\n            if (value !== null) {\n                let item = itemsByValue.get(value);\n                if (item && item.element) {\n                    item.element.element.classList.toggle(\"selected\");\n                    chainExpand(item);\n                }\n            }\n        }\n        let watch = (0, control_1.makeNodeBoundWatcher)(treeListRoot);\n        let oldValue = value();\n        watch(value, newValue => {\n            toggleSelectionOn(oldValue);\n            toggleSelectionOn(newValue);\n            oldValue = newValue;\n        });\n        watch(options.items, newItems => setItems(newItems));\n        return { element: treeListRoot };\n    }\n    exports.treeList = treeList;\n}\n"],["/client/controls/composite/plan_edit/plan_edit_controls",["/client/controls/specific/save_button","/client/utils/dom_utils","/client/controls/composite/plan_edit/plan_edit_floor_controls","/client/controls/common/panel","/client/boundable/boundable","/client/controls/composite/plan_edit/plan_edit_file_controls"],"function (exports, require, save_button_1, dom_utils_1, plan_edit_floor_controls_1, panel_1, boundable_1, plan_edit_file_controls_1) {\n    function getPlanEditControls(context) {\n        return (0, panel_1.panel)({\n            class: \"plan-edit-controls-container\",\n            hidden: (0, boundable_1.computable)(() => !context.state.isInEditMode() || !context.state.isPlanActive())\n        }, [\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label big\", text: \"Общий план\" }),\n                (0, save_button_1.getSaveButton)(context)\n            ]),\n            ...(0, plan_edit_floor_controls_1.getPlanEditFloorControls)(context),\n            ...(0, plan_edit_file_controls_1.getPlanEditFileControls)(context)\n        ]);\n    }\n    exports.getPlanEditControls = getPlanEditControls;\n}\n"],["/client/controls/composite/plan_edit/plan_edit_file_controls",["/client/utils/dom_utils","/client/boundable/boundable","/client/controls/common/button","/client/controls/common/tree_list","/common/utils"],"function (exports, require, dom_utils_1, boundable_1, button_1, tree_list_1, utils_1) {\n    function filenameToPanoramId(filename) {\n        return filename.toLowerCase().replace(/\\.[^./\\\\]*$/, \"\");\n    }\n    function fsTreeToTreeListNodes(fsTree) {\n        let treeItems = [];\n        let visit = (node, parentPath) => {\n            var _a;\n            let currentFullPath = (parentPath ? parentPath + \"/\" : \"\") + node.name;\n            let panoramId = node.children ? undefined : filenameToPanoramId(currentFullPath);\n            let label = node.name;\n            if (node.dimensions) {\n                label += ` (${node.dimensions.width} x ${node.dimensions.height})`;\n            }\n            return {\n                label: label,\n                items: (_a = node.children) === null || _a === void 0 ? void 0 : _a.map(node => visit(node, currentFullPath)),\n                value: panoramId\n            };\n        };\n        fsTree.forEach(node => {\n            let treeNode = visit(node, \"\");\n            treeItems.push(treeNode);\n        });\n        return treeItems;\n    }\n    function fsTreeToPanoramFsPath(fsTree) {\n        let panorams = {};\n        let visit = (node, parentPath) => {\n            let currentFullPath = (parentPath ? parentPath + \"/\" : \"\") + node.name;\n            let panoramId = undefined;\n            if (node.children) {\n                node.children.forEach(node => visit(node, currentFullPath));\n            }\n            else {\n                panoramId = filenameToPanoramId(currentFullPath);\n                panorams[panoramId] = currentFullPath;\n            }\n        };\n        fsTree.forEach(node => visit(node, \"\"));\n        return panorams;\n    }\n    async function loadPanoramsFromFs(context) {\n        try {\n            let fsPanoramTree = await context.api.enumeratePanoramFiles();\n            context.state.panoramFsTree(fsPanoramTree);\n            let allPanoramFsPaths = fsTreeToPanoramFsPath(fsPanoramTree);\n            let knownPanorams = context.settings.panorams();\n            for (let knownPanoramId in knownPanorams) {\n                let newPanoramFilename = allPanoramFsPaths[knownPanoramId];\n                if (newPanoramFilename) {\n                    knownPanorams[knownPanoramId].filename = newPanoramFilename;\n                }\n            }\n            for (let newPanoramId in allPanoramFsPaths) {\n                if (!(newPanoramId in knownPanorams)) {\n                    knownPanorams[newPanoramId] = { filename: allPanoramFsPaths[newPanoramId] };\n                }\n            }\n            context.settings.panorams(knownPanorams);\n        }\n        catch (e) {\n            (0, utils_1.logError)(e);\n        }\n    }\n    function getPlanEditFileControls(context) {\n        let panoramTreeList = (0, tree_list_1.treeList)({\n            value: context.state.selectedImage,\n            items: (0, boundable_1.computable)(() => fsTreeToTreeListNodes(context.state.panoramFsTree()))\n        });\n        loadPanoramsFromFs(context);\n        let addPanoramToFloorButton = (0, button_1.button)({\n            text: \"+\",\n            disabled: (0, boundable_1.computable)(() => {\n                var _a;\n                let panoramId = context.state.selectedImage();\n                let floorId = context.state.selectedFloor();\n                return floorId === null ||\n                    panoramId === null ||\n                    ((_a = context.settings.panorams()[panoramId].position) === null || _a === void 0 ? void 0 : _a.floorId) === floorId;\n            }),\n            onclick: () => {\n                let panoramId = context.state.selectedImage();\n                let floorId = context.state.selectedFloor();\n                if (!panoramId || !floorId) {\n                    return;\n                }\n                let panorams = context.settings.panorams();\n                let panoram = panorams[panoramId];\n                if (!panoram.position) {\n                    panoram.position = { floorId, x: 0, y: 0, rotation: 0 };\n                    context.settings.panorams.notify();\n                }\n                else if (panoram.position.floorId !== floorId) {\n                    panoram.position.floorId = floorId;\n                    context.settings.panorams.notify();\n                }\n            }\n        });\n        let removePanoramFromFloorButton = (0, button_1.button)({\n            text: \"-\",\n            disabled: (0, boundable_1.computable)(() => {\n                let panoramId = context.state.selectedImage();\n                let panorams = context.settings.panorams();\n                return panoramId === null || !panorams[panoramId].position;\n            }),\n            onclick: () => {\n                let panoramId = context.state.selectedImage();\n                if (!panoramId) {\n                    return;\n                }\n                let panorams = context.settings.panorams();\n                let panoram = panorams[panoramId];\n                delete panoram.position;\n                delete panoram.links;\n                context.settings.panorams.notify();\n            }\n        });\n        let setImageBeFloorTexture = (0, button_1.button)({\n            text: \"+\",\n            disabled: (0, boundable_1.computable)(() => {\n                let imgId = context.state.selectedImage();\n                let floorId = context.state.selectedFloor();\n                let floors = context.settings.floors();\n                return !imgId || !floorId || floors[floorId].texture === imgId;\n            }),\n            onclick: () => {\n                let imgId = context.state.selectedImage();\n                let floorId = context.state.selectedFloor();\n                if (!imgId || !floorId) {\n                    return;\n                }\n                let floors = context.settings.floors();\n                floors[floorId].texture = imgId;\n                context.settings.floors(floors);\n            }\n        });\n        let clearFloorTexture = (0, button_1.button)({\n            text: \"-\",\n            disabled: (0, boundable_1.computable)(() => {\n                let floorId = context.state.selectedFloor();\n                let floors = context.settings.floors();\n                return !floorId || !floors[floorId].texture;\n            }),\n            onclick: () => {\n                let floorId = context.state.selectedFloor();\n                if (!floorId) {\n                    return;\n                }\n                let floors = context.settings.floors();\n                delete floors[floorId].texture;\n                context.settings.floors(floors);\n            }\n        });\n        return [\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label medium\", text: \"Панорамы\" }),\n                addPanoramToFloorButton, removePanoramFromFloorButton\n            ]),\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label medium\", text: \"Текстура этажа\" }),\n                setImageBeFloorTexture, clearFloorTexture\n            ]),\n            panoramTreeList\n        ];\n    }\n    exports.getPlanEditFileControls = getPlanEditFileControls;\n}\n"],["/client/controls/composite/plan_edit/plan_edit_floor_controls",["/client/boundable/boundable","/client/controls/common/button","/client/controls/common/drop_down_list","/client/controls/common/number_input","/client/controls/control","/common/utils","/client/utils/dom_utils"],"function (exports, require, boundable_1, button_1, drop_down_list_1, number_input_1, control_1, utils_1, dom_utils_1) {\n    function getPlanEditFloorControls(context) {\n        let floorSelector = (0, drop_down_list_1.dropDownList)({\n            options: (0, boundable_1.computable)(() => {\n                let floors = context.settings.floors();\n                return Object.keys(floors)\n                    .map(floorId => {\n                    let floor = floors[floorId];\n                    return { label: floor.label, value: floorId };\n                });\n            }),\n            value: context.state.selectedFloor\n        });\n        let addFloorButton = (0, button_1.button)({\n            text: \"+\",\n            onclick: () => {\n                let floors = context.settings.floors();\n                let id = (0, utils_1.randomUniqId)(floors);\n                let floor = { label: \"Этаж\", x: 0, y: 0, z: 0, width: 10, length: 10, rotation: 0 };\n                floors[id] = (floor);\n                context.settings.floors(floors);\n                context.state.selectedFloor(id);\n            }\n        });\n        let renameFloorButton = (0, button_1.button)({\n            text: \"Имя\",\n            disabled: (0, boundable_1.computable)(() => context.state.selectedFloor() === null),\n            onclick: () => {\n                let floorId = context.state.selectedFloor();\n                if (floorId) {\n                    let newName = prompt(\"Введите имя этажа:\");\n                    if (newName !== null) {\n                        let floors = context.settings.floors();\n                        floors[floorId].label = newName;\n                        context.settings.floors(floors);\n                    }\n                }\n            }\n        });\n        let deleteFloorButton = (0, button_1.button)({\n            text: \"-\",\n            disabled: (0, boundable_1.computable)(() => context.state.selectedFloor() === null),\n            onclick: () => {\n                let floorId = context.state.selectedFloor();\n                if (floorId) {\n                    let floors = context.settings.floors();\n                    delete floors[floorId];\n                    context.settings.floors(floors);\n                }\n            }\n        });\n        let hideInactiveFloorsToggleButton = (0, button_1.button)({\n            text: \"Прятать\",\n            onclick: () => {\n                context.state.hideInactiveFloors(!context.state.hideInactiveFloors());\n            }\n        });\n        let watch = (0, control_1.makeNodeBoundWatcher)(floorSelector.element);\n        let makeFloorBoundNumberInput = (propName, mult = 1) => {\n            let input = (0, number_input_1.numberInput)({\n                disabled: (0, boundable_1.computable)(() => context.state.selectedFloor() === null)\n            });\n            let lastUpdatedFloorByKey = null;\n            watch(input.value, value => {\n                let floorId = context.state.selectedFloor();\n                if (floorId && floorId === lastUpdatedFloorByKey) {\n                    let floors = context.settings.floors();\n                    floors[floorId][propName] = value / mult;\n                    context.settings.floors(floors);\n                }\n            });\n            watch(context.state.selectedFloor, floorId => {\n                if (!floorId) {\n                    input.value(0);\n                }\n                else {\n                    let floor = context.settings.floors()[floorId];\n                    input.value(floor[propName] * mult);\n                }\n                lastUpdatedFloorByKey = floorId;\n            });\n            return input;\n        };\n        let widthInput = makeFloorBoundNumberInput(\"width\");\n        let lengthInput = makeFloorBoundNumberInput(\"length\");\n        let rotationInput = makeFloorBoundNumberInput(\"rotation\", 180 / Math.PI);\n        return [\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label medium\", text: \"Этаж\" }),\n                addFloorButton, renameFloorButton, deleteFloorButton, hideInactiveFloorsToggleButton\n            ]),\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label editor\", text: \"Ширина\" }),\n                widthInput,\n                (0, dom_utils_1.tag)({ class: \"label editor\", text: \"Длина\" }),\n                lengthInput,\n                (0, dom_utils_1.tag)({ class: \"label editor\", text: \"Поворот\" }),\n                rotationInput\n            ]),\n            floorSelector,\n        ];\n    }\n    exports.getPlanEditFloorControls = getPlanEditFloorControls;\n}\n"],["/client/controls/composite/settings_edit_controls",["/client/controls/common/button","/client/controls/common/collapser","/client/controls/specific/save_button","/client/controls/common/slider","/client/utils/dom_utils","/client/controls/common/panel","/client/boundable/boundable"],"function (exports, require, button_1, collapser_1, save_button_1, slider_1, dom_utils_1, panel_1, boundable_1) {\n    function getSettingsEditControls(context) {\n        let wireframeButton = (0, button_1.button)({\n            text: \"Грани\",\n            onclick: () => context.settings.skyboxWireframe(!context.settings.skyboxWireframe())\n        });\n        return (0, panel_1.panel)({\n            class: \"settings-edit-controls-container\",\n            hidden: (0, boundable_1.computable)(() => !context.state.isInEditMode() || context.state.isPlanActive())\n        }, [\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label big\", text: \"Настройки\" }),\n                (0, save_button_1.getSaveButton)(context)\n            ]),\n            (0, collapser_1.collapser)({ text: \"Просмотрщик\" }, [\n                (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                    wireframeButton\n                ]),\n                (0, slider_1.slider)({\n                    label: \"Радиус цилиндра\", units: \"м\",\n                    min: 0.5, value: context.settings.skyboxRadius, max: 5\n                }),\n                (0, slider_1.slider)({\n                    label: \"Высота цилиндра\", units: \"м\",\n                    min: 2, value: context.settings.skyboxHeight, max: 10\n                }),\n                (0, slider_1.slider)({\n                    label: \"Боковые сегменты\",\n                    min: 3, value: context.settings.skyboxRadialSegments, max: 512,\n                    integer: true\n                }),\n                (0, slider_1.slider)({\n                    label: \"FOV\",\n                    min: 30, value: context.settings.fov, max: 180\n                }),\n                (0, slider_1.slider)({\n                    label: \"Мин.наклон камеры\",\n                    min: -Math.PI / 2, value: context.settings.minPitch, max: 0\n                }),\n                (0, slider_1.slider)({\n                    label: \"Макс.наклон камеры\",\n                    min: 0, value: context.settings.maxPitch, max: Math.PI / 2\n                }),\n                (0, slider_1.slider)({\n                    label: \"Высота камеры\",\n                    min: 0, value: context.settings.cameraHeight, max: 2\n                }),\n                (0, slider_1.slider)({\n                    label: \"Скорость поворота\",\n                    min: 1 / 2000, value: context.settings.cameraRotationSpeed, max: 1 / 100\n                })\n            ])\n        ]);\n    }\n    exports.getSettingsEditControls = getSettingsEditControls;\n}\n"],["/client/controls/control",["/client/boundable/boundable","/client/utils/dom_utils","/client/utils/watch_node_inserted_removed"],{"exports":["isControl","makeNodeBoundWatcher"]},"function (exports, require, boundable_1, dom_utils_1, watch_node_inserted_removed_1) {\n    function isControl(x) {\n        return !!x && typeof (x) === \"object\" && x.element instanceof HTMLElement;\n    }\n    exports.isControl = isControl;\n    const emptyValue = {};\n    function makeNodeBoundWatcher(node, opts = {}) {\n        let handlers = [];\n        let inDomNow = (0, dom_utils_1.isInDOM)(node);\n        function onNodeInserted() {\n            (0, watch_node_inserted_removed_1.watchNodeRemoved)(node, onNodeRemoved);\n            for (let i = 0; i < handlers.length; i++) {\n                let handler = handlers[i];\n                handler.clear = handler.boundable.subscribe(handler.handler);\n                let currentValue = handler.boundable();\n                if ((0, boundable_1.boundableContentCanBeDifferent)(handler.lastKnownValue, currentValue)) {\n                    handler.lastKnownValue = currentValue;\n                    handler.handler(currentValue);\n                }\n            }\n            if (!opts.preventDisplayChange) {\n                node.style.display = \"\";\n            }\n        }\n        function onNodeRemoved() {\n            (0, watch_node_inserted_removed_1.watchNodeInserted)(node, onNodeInserted);\n            if (!opts.preventDisplayChange) {\n                node.style.display = \"none\";\n            }\n            for (let i = 0; i < handlers.length; i++) {\n                let handler = handlers[i];\n                if (handler.clear) {\n                    handler.clear();\n                    handler.clear = null;\n                }\n                handler.lastKnownValue = handler.boundable();\n            }\n        }\n        if (inDomNow) {\n            onNodeInserted();\n        }\n        else {\n            onNodeRemoved();\n        }\n        return (boundable, handler) => {\n            if (!(0, boundable_1.isBoundable)(boundable)) {\n                handler(boundable);\n                return () => {\n                };\n            }\n            let obj = {\n                boundable,\n                handler: handler,\n                lastKnownValue: !inDomNow ? emptyValue : boundable(),\n                clear: !inDomNow ? null : boundable.subscribe(handler)\n            };\n            handlers.push(obj);\n            if (inDomNow) {\n                handler(boundable());\n            }\n            return () => {\n                handlers = handlers.filter(x => x !== obj);\n                if (obj.clear) {\n                    obj.clear();\n                    obj.clear = null;\n                }\n            };\n        };\n    }\n    exports.makeNodeBoundWatcher = makeNodeBoundWatcher;\n}\n"],["/client/controls/specific/save_button",["/client/boundable/boundable","/client/controls/common/button"],"function (exports, require, boundable_1, button_1) {\n    function getSaveButton(context) {\n        let saveButton = (0, button_1.button)({\n            disabled: (0, boundable_1.computable)(() => !context.settings.hasUnsavedChanges()),\n            onclick: () => context.settings.save(),\n            text: \"Сохранить\"\n        });\n        return saveButton;\n    }\n    exports.getSaveButton = getSaveButton;\n}\n"],["/client/gizmo_controller",["/client/skybox_controller","/client/threejs_decl","/client/threejs_decl"],"function (exports, require, skybox_controller_1, threejs_decl_1, threejs_decl_2) {\n    class GizmoController extends skybox_controller_1.SkyboxController {\n        constructor(settings, context) {\n            super(settings, context);\n            this.gizmo = this.makeGizmo();\n        }\n        makeGizmo() {\n            let arrowHeight = 10;\n            let arrowWidth = arrowHeight / 5;\n            let shaftRadius = arrowWidth / 5;\n            let peakHeight = arrowHeight / 5;\n            let shaftGeom = new threejs_decl_1.THREE.CylinderGeometry(shaftRadius, shaftRadius, arrowHeight - peakHeight, 3);\n            let peakGeom = new threejs_decl_1.THREE.ConeGeometry(arrowWidth / 2, peakHeight, 6);\n            let wrapGeom = new threejs_decl_1.THREE.CylinderGeometry(arrowWidth / 1.5, arrowWidth / 1.5, arrowHeight + arrowWidth);\n            let makeArrow = (direction) => {\n                let wrapMaterial = new threejs_decl_1.THREE.MeshBasicMaterial({\n                    color: direction === \"x\" ? \"#f00\" : direction === \"y\" ? \"#00f\" : \"#0f0\",\n                    side: threejs_decl_1.THREE.FrontSide,\n                    opacity: 0,\n                    transparent: true\n                });\n                let baseMaterial = new threejs_decl_1.THREE.MeshBasicMaterial({\n                    color: direction === \"x\" ? \"#f00\" : direction === \"y\" ? \"#00f\" : \"#0f0\",\n                    side: threejs_decl_1.THREE.FrontSide\n                });\n                let result = new threejs_decl_1.THREE.Group();\n                let shaft = new threejs_decl_1.THREE.Mesh(shaftGeom, baseMaterial);\n                shaft.position.y = (arrowHeight - peakHeight) / 2;\n                result.add(shaft);\n                let peak = new threejs_decl_1.THREE.Mesh(peakGeom, baseMaterial);\n                peak.position.y = arrowHeight - (peakHeight / 2);\n                result.add(peak);\n                let wrap = new threejs_decl_1.THREE.Mesh(wrapGeom, wrapMaterial);\n                wrap.position.y = arrowHeight / 2;\n                wrap.name = \"wrap_\" + direction;\n                result.add(wrap);\n                switch (direction) {\n                    case \"x\":\n                        result.rotation.z = -Math.PI / 2;\n                        break;\n                    case \"z\":\n                        result.rotation.x = -Math.PI / 2;\n                        break;\n                }\n                return result;\n            };\n            let yArrow = makeArrow(\"y\");\n            let xArrow = makeArrow(\"x\");\n            let zArrow = makeArrow(\"z\");\n            let gizmo = new threejs_decl_1.THREE.Group();\n            gizmo.add(xArrow);\n            gizmo.add(yArrow);\n            gizmo.add(zArrow);\n            if ((0, threejs_decl_2.isInteractiveObject)(gizmo)) {\n                gizmo.cursor = \"pointer\";\n                gizmo.on(\"mousedown\", evt => this.startMovement(evt));\n            }\n            return gizmo;\n        }\n        startMovement(evt) {\n            let origEvent = evt.data.originalEvent;\n            let startX = 0;\n            let startY = 0;\n            if (origEvent instanceof MouseEvent) {\n                startX = origEvent.clientX;\n                startY = origEvent.clientY;\n            }\n            else if (origEvent instanceof TouchEvent) {\n                let touch = origEvent.touches[0];\n                if (!touch) {\n                    return;\n                }\n                startX = touch.clientX;\n                startY = touch.clientY;\n            }\n            else {\n                return;\n            }\n            let firstWrapIntersect = evt.intersects.filter(x => x.object.name.startsWith(\"wrap_\"))[0];\n            const movedObject = this.context.state.selectedSceneObject();\n            if (!firstWrapIntersect || !movedObject) {\n                return;\n            }\n            let firstWrap = firstWrapIntersect.object;\n            let distanceToIntersection = firstWrapIntersect.distance;\n            let direction = firstWrap.name.substr(5);\n            let startObjValue = movedObject.object.position[direction];\n            let startGizmoValue = this.gizmo.position[direction];\n            let camCosX = Math.cos(this.camera.rotation.x);\n            let camSinX = Math.sin(this.camera.rotation.x);\n            let camCosY = Math.cos(this.camera.rotation.y);\n            let camSinY = Math.sin(this.camera.rotation.y);\n            let vFOV = (this.camera.fov) * (Math.PI / 180);\n            let screenHeight = document.body.clientHeight;\n            let onMove = (x, y) => {\n                let dx = startX - x;\n                let dy = startY - y;\n                let dVal;\n                switch (direction) {\n                    case \"y\": {\n                        let dPx = dy * camCosX;\n                        let dAngle = (vFOV * (dPx / screenHeight));\n                        dVal = distanceToIntersection * Math.tan(dAngle);\n                        console.log({ dPx, dAngle, dVal });\n                        break;\n                    }\n                    case \"x\":\n                        dVal = ((dx * camCosY) + (dy * camSinY)) * camSinX;\n                        break;\n                    case \"z\":\n                        dVal = (-(dx * camSinY) + (dy * camCosY)) * camSinX;\n                        break;\n                }\n                movedObject.object.position[direction] = startObjValue + dVal;\n                this.gizmo.position[direction] = startGizmoValue + dVal;\n            };\n            let onMouseMove = (e) => {\n                onMove(e.clientX, e.clientY);\n            };\n            let onTouchMove = (e) => {\n                let touch = e.touches[0];\n                if (touch) {\n                    onMove(touch.clientX, touch.clientY);\n                }\n            };\n            let onMovementFinish = () => {\n                window.removeEventListener(\"mousemove\", onMouseMove);\n                window.removeEventListener(\"touchmove\", onTouchMove);\n                window.removeEventListener(\"touchend\", onMovementFinish);\n                window.removeEventListener(\"mouseup\", onMovementFinish);\n            };\n            window.addEventListener(\"mousemove\", onMouseMove);\n            window.addEventListener(\"touchmove\", onTouchMove);\n            window.addEventListener(\"touchend\", onMovementFinish);\n            window.addEventListener(\"mouseup\", onMovementFinish);\n        }\n        addGizmoHandlers(obj, description, onMoved) {\n            if (!(0, threejs_decl_2.isInteractiveObject)(obj)) {\n                return;\n            }\n            obj.on(\"click\", clickEvent => {\n                if (!this.context.state.isInEditMode()) {\n                    return;\n                }\n                this.context.state.selectedSceneObject({\n                    ...description,\n                    object: obj\n                });\n                const target = clickEvent.currentTarget || clickEvent.target;\n                const intersection = clickEvent.intersects.sort((a, b) => a.distance - b.distance)[0];\n                if (!target || !intersection) {\n                    return;\n                }\n                let scale = intersection.distance / 75;\n                this.gizmo.position.x = intersection.point.x + scale;\n                this.gizmo.position.y = intersection.point.y + scale;\n                this.gizmo.position.z = intersection.point.z + scale;\n                this.gizmo.scale.x = this.gizmo.scale.y = this.gizmo.scale.z = scale;\n                this.scene.add(this.gizmo);\n                void onMoved;\n            });\n        }\n        clearGizmo() {\n            this.scene.remove(this.gizmo);\n        }\n    }\n    exports.GizmoController = GizmoController;\n}\n"],["/client/keyboard_camera_movement","function (exports, require) {\n    function setupKeyboardCameraMovement(camera, speed) {\n        let directMovement = 0;\n        let strafeMovement = 0;\n        let yMovement = 0;\n        let shouldHandle = () => {\n            if (document.activeElement) {\n                let name = document.activeElement.tagName.toUpperCase();\n                if (name === \"INPUT\" || name === \"SELECT\") {\n                    return false;\n                }\n            }\n            return true;\n        };\n        let handleKeydown = (e) => {\n            if (!shouldHandle()) {\n                return;\n            }\n            switch (e.key.toLowerCase()) {\n                case \"a\":\n                    strafeMovement = -1;\n                    break;\n                case \"d\":\n                    strafeMovement = +1;\n                    break;\n                case \"s\":\n                    directMovement = -1;\n                    break;\n                case \"w\":\n                    directMovement = +1;\n                    break;\n                case \"shift\":\n                    yMovement = -1;\n                    break;\n                case \" \":\n                    yMovement = +1;\n                    break;\n            }\n        };\n        let handleKeyup = (e) => {\n            if (!shouldHandle()) {\n                return;\n            }\n            switch (e.key.toLowerCase()) {\n                case \"a\":\n                    if (strafeMovement === -1) {\n                        strafeMovement = 0;\n                    }\n                    break;\n                case \"d\":\n                    if (strafeMovement === +1) {\n                        strafeMovement = 0;\n                    }\n                    break;\n                case \"s\":\n                    if (directMovement === -1) {\n                        directMovement = 0;\n                    }\n                    break;\n                case \"w\":\n                    if (directMovement === +1) {\n                        directMovement = 0;\n                    }\n                    break;\n                case \"shift\":\n                    if (yMovement === -1) {\n                        yMovement = 0;\n                    }\n                    break;\n                case \" \":\n                    if (yMovement === +1) {\n                        yMovement = 0;\n                    }\n                    break;\n            }\n        };\n        window.addEventListener(\"keydown\", handleKeydown);\n        window.addEventListener(\"keyup\", handleKeyup);\n        return {\n            clear() {\n                window.removeEventListener(\"keydown\", handleKeydown);\n                window.removeEventListener(\"keyup\", handleKeyup);\n            },\n            onFrame(timePassed) {\n                if (yMovement) {\n                    camera.position.y += yMovement * speed * timePassed;\n                }\n                if (directMovement || strafeMovement) {\n                    let direct = directMovement * speed * timePassed;\n                    let strafe = strafeMovement * speed * timePassed;\n                    let sin = Math.sin(camera.rotation.y);\n                    let cos = Math.cos(camera.rotation.y);\n                    camera.position.x -= (sin * direct) - (cos * strafe);\n                    camera.position.z -= (cos * direct) + (sin * strafe);\n                }\n            }\n        };\n    }\n    exports.setupKeyboardCameraMovement = setupKeyboardCameraMovement;\n}\n"],["/client/layout_controller",["/client/boundable/boundable","/client/controls/common/button","/client/utils/dom_utils","/client/controls/common/panel","/client/controls/control","/client/controls/composite/settings_edit_controls","/client/controls/composite/plan_edit/plan_edit_controls"],"function (exports, require, boundable_1, button_1, dom_utils_1, panel_1, control_1, settings_edit_controls_1, plan_edit_controls_1) {\n    class LayoutController {\n        constructor(context, options) {\n            this.context = context;\n            this.options = options;\n            this.planboxContainer = (0, dom_utils_1.tag)({ class: \"planbox-container-nested\" });\n            this.planRoot = (0, dom_utils_1.tag)({ class: \"planbox-container\" }, [this.planboxContainer]);\n            this.skyboxContainer = (0, panel_1.panel)({ class: \"skybox-container\" });\n        }\n        start() {\n            this.options.root.appendChild(this.planRoot);\n            this.options.root.appendChild(this.skyboxContainer);\n            this.options.root.appendChild((0, dom_utils_1.tag)({ class: \"view-control-buttons-container\" }, [\n                !this.options.canEdit ? null : (0, button_1.button)({\n                    text: \"Редактирование\",\n                    onclick: () => this.context.state.isInEditMode(!this.context.state.isInEditMode())\n                }),\n                (0, button_1.button)({\n                    text: (0, boundable_1.computable)(() => this.context.state.isPlanActive() ? \"Панорама\" : \"План\"),\n                    onclick: () => this.context.state.isPlanActive(!this.context.state.isPlanActive())\n                })\n            ]));\n            this.options.root.appendChild((0, settings_edit_controls_1.getSettingsEditControls)(this.context));\n            this.planRoot.insertBefore((0, plan_edit_controls_1.getPlanEditControls)(this.context), this.planboxContainer);\n            let watch = (0, control_1.makeNodeBoundWatcher)(this.options.root);\n            watch(this.context.state.isPlanActive, isPlan => {\n                this.planRoot.style.display = isPlan ? \"\" : \"none\";\n                this.skyboxContainer.style.display = isPlan ? \"none\" : \"\";\n                if (isPlan) {\n                    this.context.skybox.stop();\n                    if (!this.context.planbox.isActive) {\n                        this.context.planbox.start(this.planboxContainer);\n                    }\n                }\n                else {\n                    this.context.planbox.stop();\n                    if (!this.context.skybox.isActive) {\n                        this.context.skybox.start(this.skyboxContainer);\n                    }\n                }\n            });\n            this.removeLoadingScreen();\n        }\n        removeLoadingScreen() {\n            let loadingScreen = document.getElementById(\"loading-screen\");\n            if (loadingScreen) {\n                loadingScreen.remove();\n            }\n        }\n    }\n    exports.LayoutController = LayoutController;\n}\n"],["/client/planbox_controller",["/client/keyboard_camera_movement","/client/threejs_decl","/client/settings_controller","/client/gizmo_controller"],"function (exports, require, keyboard_camera_movement_1, threejs_decl_1, settings_controller_1, gizmo_controller_1) {\n    class PlanboxController extends gizmo_controller_1.GizmoController {\n        constructor(context) {\n            super(context.settings.clone({\n                ...settings_controller_1.defaultViewSettings,\n                fov: context.settings.fov(),\n                skyboxHeight: 2,\n                skyboxRadialSegments: 4\n            }), context);\n            this.keyboardCameraControls = null;\n            this.floors = {};\n            new threejs_decl_1.THREE.Interaction(this.renderer, this.scene, this.camera);\n            this.camera.position.x = 100;\n            this.camera.position.z = 100;\n            this.camera.position.y = 1100;\n            this.camera.lookAt(0, 1000, 0);\n            this.watch(context.settings.floors, floors => this.updateFloors(floors));\n        }\n        stop() {\n            super.stop();\n            if (this.keyboardCameraControls) {\n                this.keyboardCameraControls.clear();\n                this.keyboardCameraControls = null;\n            }\n            for (let floorId in this.floors) {\n                let obj = this.floors[floorId];\n                this.scene.remove(obj.object);\n                obj.geometry.dispose();\n            }\n        }\n        start(el) {\n            super.start(el);\n            this.keyboardCameraControls = (0, keyboard_camera_movement_1.setupKeyboardCameraMovement)(this.camera, 0.05);\n        }\n        createFloorObject(floor, floorId) {\n            let geometry = new threejs_decl_1.THREE.PlaneGeometry(floor.width, floor.length);\n            let texture = undefined;\n            let material;\n            if (floor.texture) {\n                texture = floor.texture;\n                material = new threejs_decl_1.THREE.MeshBasicMaterial({\n                    map: this.textureRepo.imageIdToTexture(floor.texture),\n                    side: threejs_decl_1.THREE.DoubleSide\n                });\n            }\n            else {\n                material = new threejs_decl_1.THREE.MeshBasicMaterial({\n                    color: \"#888\",\n                    side: threejs_decl_1.THREE.DoubleSide,\n                    opacity: 0.5,\n                    transparent: true\n                });\n            }\n            let obj = new threejs_decl_1.THREE.Mesh(geometry, material);\n            obj.position.y = floor.y + 1000;\n            obj.position.x = floor.x;\n            obj.position.z = floor.z;\n            obj.rotation.x = Math.PI / 2;\n            obj.rotation.z = floor.rotation;\n            this.addGizmoHandlers(obj, { type: \"floor\", floorId }, x => console.log(\"Moved!\", x));\n            return { geometry, object: obj, material, texture };\n        }\n        onFrame(timePassed) {\n            super.onFrame(timePassed);\n            if (this.keyboardCameraControls) {\n                this.keyboardCameraControls.onFrame(timePassed);\n            }\n        }\n        updateCamera() {\n        }\n        updateFloors(floors) {\n            for (let floorId in this.floors) {\n                let obj = this.floors[floorId];\n                delete this.floors[floorId];\n                this.scene.remove(obj.object);\n                obj.geometry.dispose();\n                if (obj.texture) {\n                    this.textureRepo.unrefTextureByImageId(obj.texture);\n                }\n                obj.material.dispose();\n            }\n            for (let floorId in floors) {\n                let floor = floors[floorId];\n                let obj = this.createFloorObject(floor, floorId);\n                this.scene.add(obj.object);\n                this.floors[floorId] = obj;\n            }\n        }\n        createSkyboxObject(material) {\n            let result = super.createSkyboxObject(material);\n            if ((0, threejs_decl_1.isInteractiveObject)(result.object)) {\n                result.object.on(\"click\", () => {\n                    this.context.state.selectedSceneObject(null);\n                    this.clearGizmo();\n                });\n            }\n            return result;\n        }\n    }\n    exports.PlanboxController = PlanboxController;\n}\n"],["/client/settings_controller",["/client/boundable/boundable"],"function (exports, require, boundable_1) {\n    exports.defaultViewSettings = {\n        cameraHeight: 1.8,\n        fov: 75,\n        maxPitch: Math.PI / 2,\n        minPitch: -(Math.PI / 2),\n        skyboxHeight: 3.5,\n        skyboxRadius: 1.5,\n        skyboxWireframe: false,\n        skyboxRadialSegments: 64,\n        cameraRotationSpeed: 1 / 350\n    };\n    const defaultBuildPlan = {\n        panorams: {},\n        floors: {}\n    };\n    const defaultSettingsPack = {\n        ...exports.defaultViewSettings,\n        ...defaultBuildPlan\n    };\n    function wrapWithBoundables(defaultValues) {\n        let result = class WrappedWithBoundables {\n            constructor() {\n                let that = this;\n                Object.keys(defaultValues).forEach(key => {\n                    that[key] = (0, boundable_1.boundValue)(defaultValues[key]);\n                });\n            }\n            setToValues(values) {\n                let that = this;\n                Object.keys(values).forEach(key => {\n                    if (!(0, boundable_1.isBoundValue)(that[key])) {\n                        console.warn(\"Cannot assign value of \" + key + \": unknown key\");\n                    }\n                    else {\n                        that[key](values[key]);\n                    }\n                });\n            }\n            extractByKeys(keys) {\n                let that = this;\n                let result = {};\n                keys.forEach(key => result[key] = that[key]());\n                return result;\n            }\n        };\n        return result;\n    }\n    class SettingsController extends wrapWithBoundables(defaultSettingsPack) {\n        constructor(viewSettings, plan, context) {\n            super();\n            this.context = context;\n            this.hasUnsavedChanges = (0, boundable_1.boundValue)(false);\n            if (viewSettings) {\n                this.setToValues(viewSettings);\n            }\n            if (plan) {\n                this.setToValues(plan);\n            }\n            Object.keys(defaultSettingsPack).forEach(key => {\n                this[key].subscribe(() => this.hasUnsavedChanges(true));\n            });\n        }\n        clone(viewSettings = null, plan = null) {\n            return new SettingsController({\n                ...this.viewSettings,\n                ...(viewSettings || {})\n            }, {\n                ...this.buildingPlan,\n                ...(plan || {})\n            }, this.context);\n        }\n        get viewSettings() {\n            return this.extractByKeys(Object.keys(exports.defaultViewSettings));\n        }\n        get buildingPlan() {\n            return this.extractByKeys(Object.keys(defaultBuildPlan));\n        }\n        async save() {\n            let buildingPlan = this.buildingPlan;\n            let panorams = { ...buildingPlan.panorams };\n            for (let panoramId in panorams) {\n                let panoram = panorams[panoramId];\n                if (!panoram.links && !panoram.position) {\n                    delete panorams[panoramId];\n                }\n            }\n            buildingPlan.panorams = panorams;\n            await Promise.all([\n                this.context.api.saveViewSettings(this.viewSettings),\n                this.context.api.saveBuildingPlan(buildingPlan)\n            ]);\n            this.hasUnsavedChanges(false);\n        }\n    }\n    exports.SettingsController = SettingsController;\n}\n"],["/client/skybox_controller",["/client/controls/control","/client/texture_repo","/client/threejs_decl","/client/utils/drag","/client/utils/graphic_utils","/client/utils/watch_node_resized"],"function (exports, require, control_1, texture_repo_1, threejs_decl_1, drag_1, graphic_utils_1, watch_node_resized_1) {\n    const defaultSkyboxPath = \"./static/default_skybox.png\";\n    class SkyboxController {\n        constructor(settings, context) {\n            this.settings = settings;\n            this.context = context;\n            this.scene = new threejs_decl_1.THREE.Scene();\n            this.camera = new threejs_decl_1.THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);\n            this.renderer = new threejs_decl_1.THREE.WebGLRenderer();\n            this.stopRaf = null;\n            this.stopResizeWatch = null;\n            this.textureRepo = new texture_repo_1.TextureRepository(this.context);\n            this.skybox = this.createSkybox();\n            this.scene.add(this.skybox.object);\n            this.camera.fov = this.settings.fov();\n            this.camera.rotation.order = \"ZYX\";\n            this.camera.position.set(0, this.settings.cameraHeight() * 1000, 0);\n            this.camera.lookAt(-1, this.settings.cameraHeight() * 1000, 0);\n            this.camera.lookAt(1, this.settings.cameraHeight() * 1000, 0);\n            this.watch = (0, control_1.makeNodeBoundWatcher)(this.canvas);\n            [settings.fov, settings.cameraHeight, settings.minPitch, settings.maxPitch]\n                .forEach(boundable => {\n                this.watch(boundable, () => this.updateCamera());\n            });\n            [settings.skyboxHeight, settings.skyboxRadius, settings.skyboxWireframe, settings.skyboxRadialSegments]\n                .forEach((boundable) => {\n                this.watch(boundable, () => this.updateSkyboxShape());\n            });\n            this.setupUserControls();\n        }\n        setupUserControls() {\n            (0, drag_1.addDragListeners)({\n                element: this.canvas,\n                rightMouseButton: true,\n                lockPointer: true,\n                onDrag: ({ dx, dy, source }) => {\n                    if (source === \"touch\") {\n                        dx *= -1;\n                        dy *= -1;\n                    }\n                    this.rotateCamera(dx, dy);\n                },\n                onDragStart: () => {\n                    let focused = document.activeElement;\n                    if (focused && focused instanceof HTMLElement) {\n                        focused.blur();\n                    }\n                }\n            });\n        }\n        get canvas() {\n            return this.renderer.domElement;\n        }\n        onResize(container) {\n            let w = container.clientWidth;\n            let h = container.clientHeight;\n            this.renderer.setSize(w, h);\n            this.camera.aspect = w / h;\n            this.camera.updateProjectionMatrix();\n        }\n        start(container) {\n            if (this.stopRaf) {\n                throw new Error(\"Already running\");\n            }\n            this.onResize(container);\n            container.appendChild(this.canvas);\n            this.stopRaf = (0, graphic_utils_1.raf)(timePassed => {\n                this.renderer.render(this.scene, this.camera);\n                this.onFrame(timePassed);\n            });\n            this.stopResizeWatch = (0, watch_node_resized_1.watchNodeResized)(container, () => this.onResize(container));\n        }\n        stop() {\n            if (this.stopRaf) {\n                this.stopRaf();\n                this.stopRaf = null;\n            }\n            if (this.stopResizeWatch) {\n                this.stopResizeWatch();\n                this.stopResizeWatch = null;\n            }\n            this.canvas.remove();\n        }\n        onFrame(timePassed) {\n            void timePassed;\n        }\n        get isActive() {\n            return !!this.stopRaf;\n        }\n        createSkybox() {\n            let texture = this.textureRepo.pathToTexture(defaultSkyboxPath);\n            let material = new threejs_decl_1.THREE.MeshBasicMaterial({ map: texture, side: threejs_decl_1.THREE.BackSide });\n            let { geometry, object: mesh } = this.createSkyboxObject(material);\n            return { texture, material, object: mesh, geometry };\n        }\n        createSkyboxObject(material) {\n            let geometry = new threejs_decl_1.THREE.CylinderGeometry(this.settings.skyboxRadius() * 1000, this.settings.skyboxRadius() * 1000, this.settings.skyboxHeight() * 1000, this.settings.skyboxRadialSegments());\n            patchCylinderUV(geometry);\n            let object;\n            if (this.settings.skyboxWireframe()) {\n                object = new threejs_decl_1.THREE.Line(geometry, material);\n            }\n            else {\n                object = new threejs_decl_1.THREE.Mesh(geometry, material);\n            }\n            object.name = \"skybox\";\n            object.position.y = (this.settings.skyboxHeight() / 2) * 1000;\n            return { geometry, object };\n        }\n        clampPitch(pitch) {\n            return Math.max(this.settings.minPitch(), Math.min(this.settings.maxPitch(), pitch));\n        }\n        rotateCamera(dx, dy) {\n            let pitch = this.camera.rotation.x + (dy * this.settings.cameraRotationSpeed());\n            this.camera.rotation.x = this.clampPitch(pitch);\n            this.camera.rotation.y += dx * this.settings.cameraRotationSpeed();\n        }\n        updateSkyboxShape() {\n            let { geometry, object } = this.createSkyboxObject(this.skybox.material);\n            this.scene.add(object);\n            this.scene.remove(this.skybox.object);\n            this.skybox.geometry.dispose();\n            this.skybox.object = object;\n            this.skybox.geometry = geometry;\n        }\n        updateCamera() {\n            this.camera.fov = this.settings.fov();\n            this.camera.position.y = this.settings.cameraHeight() * 1000;\n            this.camera.rotation.x = this.clampPitch(this.camera.rotation.x);\n            this.camera.updateProjectionMatrix();\n        }\n    }\n    exports.SkyboxController = SkyboxController;\n    function patchCylinderUV(geom) {\n        let cylinderSideUVs = new Map();\n        let pos = geom.attributes.position;\n        let uv = geom.attributes.uv;\n        let norm = geom.attributes.normal;\n        function makePosKey(i) {\n            return pos.getX(i).toFixed(3) + \"|\" + pos.getY(i).toFixed(3) + \"|\" + pos.getZ(i).toFixed(3);\n        }\n        for (let i = 0; i < uv.count; i++) {\n            let normY = norm.getY(i);\n            if (normY < 0.0001 && normY > -0.0001) {\n                cylinderSideUVs.set(makePosKey(i), { x: uv.getX(i), y: uv.getY(i) });\n            }\n        }\n        let sideCount = (uv.count - 4) / 6;\n        let topCenterVertexIndexStart = (sideCount * 2) + 2;\n        let bottomCenterVertexIndexStart = (sideCount * 4) + 3;\n        for (let i = 0; i < uv.count; i++) {\n            let normY = norm.getY(i);\n            if (normY > 0.0001 || normY < -0.0001) {\n                let posX = pos.getX(i), posZ = pos.getZ(i);\n                if (posX < 0.0001 && posX > -0.0001 && posZ < 0.0001 && posZ > -0.0001) {\n                    let isTop = normY > 0;\n                    let indexStart = isTop ? topCenterVertexIndexStart : bottomCenterVertexIndexStart;\n                    let offset = ((i - indexStart) + 0.5) / sideCount;\n                    uv.setX(i, offset);\n                    uv.setY(i, isTop ? 1 : 0);\n                }\n                else {\n                    let goodUV = cylinderSideUVs.get(makePosKey(i));\n                    if (goodUV) {\n                        uv.setX(i, goodUV.x);\n                        uv.setY(i, goodUV.y);\n                    }\n                    else {\n                        console.warn(`Found NO good UV for position ${pos.getX(i)},${pos.getY(i)},${pos.getZ(i)}`);\n                    }\n                }\n            }\n        }\n        uv.needsUpdate = true;\n    }\n}\n"],["/client/texture_repo",["/client/threejs_decl"],"function (exports, require, threejs_decl_1) {\n    class TextureRepository {\n        constructor(context) {\n            this.context = context;\n            this.textureLoader = new threejs_decl_1.THREE.TextureLoader();\n            this.textures = {};\n            this.cleanupList = new Set();\n            this.cleanupHandler = null;\n        }\n        pathToTexture(path) {\n            if (!this.textures[path]) {\n                this.textures[path] = {\n                    texture: this.textureLoader.load(path),\n                    refCount: 1\n                };\n            }\n            else {\n                this.textures[path].refCount++;\n            }\n            return this.textures[path].texture;\n        }\n        imageIdToPath(imageId) {\n            let panorams = this.context.settings.panorams();\n            let panoram = panorams[imageId];\n            return \"./img/\" + panoram.filename;\n        }\n        imageIdToTexture(imageId) {\n            return this.pathToTexture(this.imageIdToPath(imageId));\n        }\n        unrefTextureByImageId(imageId) {\n            this.unrefTextureByPath(this.imageIdToPath(imageId));\n        }\n        unrefTextureByPath(path) {\n            let descr = this.textures[path];\n            descr.refCount--;\n            if (descr.refCount < 1) {\n                this.cleanupList.add(path);\n                this.initCleanup();\n            }\n        }\n        initCleanup() {\n            if (!this.cleanupHandler) {\n                this.cleanupHandler = setTimeout(() => {\n                    this.cleanupHandler = null;\n                    this.cleanupList.forEach(path => {\n                        let item = this.textures[path];\n                        if (item.refCount === 0) {\n                            delete this.textures[path];\n                            item.texture.dispose();\n                        }\n                    });\n                    this.cleanupList.clear();\n                }, 1000);\n            }\n        }\n    }\n    exports.TextureRepository = TextureRepository;\n}\n"],["/client/threejs_decl","function (exports, require) {\n    exports.THREE = window.THREE;\n    function isInteractiveObject(x) {\n        return typeof (x.on) === \"function\";\n    }\n    exports.isInteractiveObject = isInteractiveObject;\n    var InteractionLib;\n    (function (InteractionLib) {\n    })(InteractionLib = exports.InteractionLib || (exports.InteractionLib = {}));\n}\n"],["/client/utils/dom_utils",["/client/controls/control"],{"exports":["isInDOM","tag","toHtmlTag"]},"function (exports, require, control_1) {\n    function tag(a, b) {\n        let description;\n        let children = undefined;\n        if (!a) {\n            description = {};\n            children = b || undefined;\n        }\n        else {\n            if (Array.isArray(a)) {\n                description = {};\n                children = a;\n            }\n            else {\n                description = a;\n                children = b || undefined;\n            }\n        }\n        let res = document.createElement(description.tagName || \"div\");\n        for (let k in description) {\n            let v = description[k];\n            switch (k) {\n                case \"tagName\":\n                    break;\n                case \"text\":\n                    res.textContent = v + \"\";\n                    break;\n                case \"class\":\n                    res.className = Array.isArray(v) ? v.filter(x => !!x).join(\" \") : v + \"\";\n                    break;\n                default:\n                    res.setAttribute(k, v + \"\");\n                    break;\n            }\n        }\n        if (children) {\n            for (let child of children) {\n                if (!child) {\n                    continue;\n                }\n                res.appendChild(child instanceof HTMLElement ? child : (0, control_1.isControl)(child) ? child.element : tag(child));\n            }\n        }\n        return res;\n    }\n    exports.tag = tag;\n    function toHtmlTag(taggable) {\n        return !taggable ? null\n            : taggable instanceof HTMLElement ? taggable\n                : (0, control_1.isControl)(taggable) ? taggable.element\n                    : tag(taggable);\n    }\n    exports.toHtmlTag = toHtmlTag;\n    function isInDOM(node) {\n        do {\n            if (node === document.body) {\n                return true;\n            }\n            if (!node.parentNode) {\n                return false;\n            }\n            node = node.parentNode;\n        } while (true);\n    }\n    exports.isInDOM = isInDOM;\n}\n"],["/client/utils/drag","function (exports, require) {\n    function addDragListeners(params) {\n        let pointerIsLocked = false;\n        let prevX = 0, prevY = 0;\n        function onTouchMove(evt) {\n            let firstTouch = evt.touches[0];\n            if (!firstTouch) {\n                onTouchEnd();\n                return;\n            }\n            params.onDrag({\n                x: firstTouch.clientX,\n                y: firstTouch.clientY,\n                dx: prevX - firstTouch.clientX,\n                dy: prevY - firstTouch.clientY,\n                source: \"touch\"\n            });\n            prevX = firstTouch.clientX;\n            prevY = firstTouch.clientY;\n        }\n        function onMouseMove(evt) {\n            if (pointerIsLocked) {\n                params.onDrag({\n                    x: evt.clientX,\n                    y: evt.clientX,\n                    dx: -evt.movementX,\n                    dy: -evt.movementY,\n                    source: \"pointer\"\n                });\n            }\n            else {\n                params.onDrag({\n                    x: evt.clientX,\n                    y: evt.clientX,\n                    dx: prevX - evt.clientX,\n                    dy: prevY - evt.clientY,\n                    source: \"pointer\"\n                });\n                prevX = evt.clientX;\n                prevY = evt.clientY;\n            }\n        }\n        function onTouchEnd() {\n            window.removeEventListener(\"touchmove\", onTouchMove);\n            window.removeEventListener(\"touchend\", onTouchEnd);\n            params.onDragEnd && params.onDragEnd();\n        }\n        function onMouseUp() {\n            window.removeEventListener(\"mousemove\", onMouseMove);\n            window.removeEventListener(\"mouseup\", onMouseUp);\n            if (pointerIsLocked) {\n                document.exitPointerLock();\n            }\n            params.onDragEnd && params.onDragEnd();\n        }\n        function installDragListeners(evt) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            params.onDragStart && params.onDragStart();\n            if (evt instanceof TouchEvent) {\n                let firstTouch = evt.touches[0];\n                prevX = firstTouch.clientX;\n                prevY = firstTouch.clientY;\n                window.addEventListener(\"touchmove\", onTouchMove, { passive: true });\n                window.addEventListener(\"touchend\", onTouchEnd, { passive: true });\n            }\n            else {\n                prevX = evt.clientX;\n                prevY = evt.clientY;\n                window.addEventListener(\"mousemove\", onMouseMove, { passive: true });\n                window.addEventListener(\"mouseup\", onMouseUp, { passive: true });\n            }\n        }\n        params.element.addEventListener(\"mousedown\", evt => {\n            let expectedButton = params.rightMouseButton ? 2 : 0;\n            if (evt.button !== expectedButton) {\n                return;\n            }\n            if (params.lockPointer && params.element instanceof HTMLCanvasElement) {\n                pointerIsLocked = lockPointer(params.element);\n            }\n            installDragListeners(evt);\n        });\n        params.element.addEventListener(\"touchstart\", evt => {\n            installDragListeners(evt);\n        }, { passive: true });\n        if (params.rightMouseButton) {\n            params.element.addEventListener(\"contextmenu\", evt => {\n                evt.preventDefault();\n                evt.stopPropagation();\n            });\n        }\n        if (params.lockPointer) {\n            document.addEventListener(\"pointerlockchange\", () => {\n                pointerIsLocked = document.pointerLockElement === params.element;\n            }, { capture: false, passive: true });\n        }\n    }\n    exports.addDragListeners = addDragListeners;\n    function lockPointer(canvas) {\n        if (!canvas.requestPointerLock) {\n            return false;\n        }\n        canvas.requestPointerLock();\n        return true;\n    }\n}\n"],["/client/utils/graphic_utils","function (exports, require) {\n    function isWebGLAvailable(version) {\n        try {\n            const canvas = document.createElement(\"canvas\");\n            if (version === 1) {\n                return !!(window.WebGLRenderingContext && (canvas.getContext(\"webgl\") || canvas.getContext('experimental-webgl')));\n            }\n            else {\n                return !!(window.WebGL2RenderingContext && canvas.getContext(\"webgl2\"));\n            }\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    exports.isWebGLAvailable = isWebGLAvailable;\n    function getWebglErrorElement(version) {\n        const names = {\n            1: \"WebGL\",\n            2: \"WebGL 2\"\n        };\n        const contexts = {\n            1: window.WebGLRenderingContext,\n            2: window.WebGL2RenderingContext\n        };\n        const result = document.createElement(\"div\");\n        result.className = \"webgl-error-message\";\n        let target = contexts[version] ? \"graphics card\" : \"browser\";\n        result.textContent = `Your ${target} does not seem to support `;\n        let link = document.createElement(\"a\");\n        link.setAttribute(\"href\", \"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\");\n        link.textContent = names[version];\n        result.appendChild(link);\n        return result;\n    }\n    exports.getWebglErrorElement = getWebglErrorElement;\n    function raf(handler) {\n        let lastInvokeTime = Date.now();\n        let stopped = false;\n        let wrappedHandler = () => {\n            if (stopped) {\n                return;\n            }\n            requestAnimationFrame(wrappedHandler);\n            let newNow = Date.now();\n            let diff = newNow - lastInvokeTime;\n            lastInvokeTime = newNow;\n            handler(diff);\n        };\n        requestAnimationFrame(wrappedHandler);\n        return () => stopped = true;\n    }\n    exports.raf = raf;\n}\n"],["/client/utils/number_utils","function (exports, require) {\n    function toFixedNoTrail(v, positions) {\n        return v.toFixed(positions).replace(/\\.?0+$/, \"\");\n    }\n    exports.toFixedNoTrail = toFixedNoTrail;\n}\n"],["/client/utils/watch_node_inserted_removed","function (exports, require) {\n    let observer = null;\n    let removableNodes = new WeakMap();\n    let insertableNodes = new WeakMap();\n    function collectHandleableNodesRecursive(node, map, destination) {\n        if (map.has(node)) {\n            destination.add(node);\n        }\n        node.childNodes.forEach(child => collectHandleableNodesRecursive(child, map, destination));\n    }\n    function dropOrInvokeHandleableNodesRecursive(node, map, oppositeNodes) {\n        let handlers = map.get(node);\n        if (handlers) {\n            if (oppositeNodes.has(node)) {\n                oppositeNodes.delete(node);\n            }\n            else {\n                map.delete(node);\n                for (let i = 0; i < handlers.length; i++) {\n                    handlers[i]();\n                }\n            }\n        }\n        node.childNodes.forEach(child => dropOrInvokeHandleableNodesRecursive(child, map, oppositeNodes));\n    }\n    function doWithRecords(records) {\n        let addedNodes = new Set();\n        for (let i = 0; i < records.length; i++) {\n            let record = records[i];\n            for (let j = 0; j < record.addedNodes.length; j++) {\n                collectHandleableNodesRecursive(record.addedNodes[j], insertableNodes, addedNodes);\n            }\n        }\n        for (let i = 0; i < records.length; i++) {\n            let record = records[i];\n            for (let j = 0; j < record.removedNodes.length; j++) {\n                dropOrInvokeHandleableNodesRecursive(record.removedNodes[j], removableNodes, addedNodes);\n            }\n        }\n        addedNodes.forEach(node => {\n            let handlers = insertableNodes.get(node);\n            if (handlers) {\n                insertableNodes.delete(node);\n                for (let i = 0; i < handlers.length; i++) {\n                    handlers[i]();\n                }\n            }\n        });\n    }\n    function init() {\n        if (observer) {\n            return;\n        }\n        observer = new MutationObserver(doWithRecords);\n        observer.observe(document.body, { childList: true, subtree: true });\n    }\n    function addHandlerToMap(map, node, handler) {\n        {\n            let arr = map.get(node);\n            if (arr) {\n                arr.push(handler);\n            }\n            else {\n                map.set(node, [handler]);\n            }\n        }\n        return () => {\n            let arr = map.get(node);\n            if (!arr) {\n                return;\n            }\n            arr = arr.filter(x => x !== handler);\n            if (arr.length > 0) {\n                map.set(node, arr);\n            }\n            else {\n                map.delete(node);\n            }\n        };\n    }\n    function watchNodeRemoved(node, handler) {\n        init();\n        return addHandlerToMap(removableNodes, node, handler);\n    }\n    exports.watchNodeRemoved = watchNodeRemoved;\n    function watchNodeInserted(node, handler) {\n        init();\n        return addHandlerToMap(insertableNodes, node, handler);\n    }\n    exports.watchNodeInserted = watchNodeInserted;\n}\n"],["/client/utils/watch_node_resized","function (exports, require) {\n    function watchNodeResized(el, handler) {\n        let requestAnimationFrame = window.requestAnimationFrame || ((cb) => window.setTimeout(cb, ~~(1000 / 60)));\n        let style = \"position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;\";\n        let styleChild = \"position: absolute; left: 0; top: 0; transition: 0s;\";\n        let wrap = document.createElement(\"div\");\n        wrap.classList.add(\"resize-sensor\");\n        wrap.style.cssText = style;\n        let expandWrap = document.createElement(\"div\");\n        expandWrap.style.cssText = style;\n        let expandChild = document.createElement(\"div\");\n        expandChild.style.cssText = styleChild;\n        expandWrap.appendChild(expandChild);\n        wrap.appendChild(expandWrap);\n        let shrinkWrap = document.createElement(\"div\");\n        shrinkWrap.style.cssText = style;\n        let shrinkChild = document.createElement(\"div\");\n        shrinkChild.style.cssText = styleChild + \"width: 200%; height: 200%;\";\n        shrinkWrap.appendChild(shrinkChild);\n        wrap.appendChild(shrinkWrap);\n        el.appendChild(wrap);\n        if (wrap.offsetParent !== el) {\n            el.style.position = \"relative\";\n        }\n        let dirty, rafId, newWidth, newHeight;\n        let lastWidth = el.offsetWidth;\n        let lastHeight = el.offsetHeight;\n        let reset = () => {\n            expandChild.style.width = \"100000px\";\n            expandChild.style.height = \"100000px\";\n            expandWrap.scrollLeft = 100000;\n            expandWrap.scrollTop = 100000;\n            shrinkWrap.scrollLeft = 100000;\n            shrinkWrap.scrollTop = 100000;\n        };\n        reset();\n        let onScroll = () => {\n            newWidth = el.offsetWidth;\n            newHeight = el.offsetHeight;\n            dirty = newWidth != lastWidth || newHeight != lastHeight;\n            if (dirty && !rafId) {\n                rafId = requestAnimationFrame(() => {\n                    rafId = 0;\n                    if (!dirty)\n                        return;\n                    lastWidth = newWidth;\n                    lastHeight = newHeight;\n                    handler();\n                });\n            }\n            reset();\n        };\n        expandWrap.addEventListener(\"scroll\", onScroll, { passive: true });\n        shrinkWrap.addEventListener(\"scroll\", onScroll, { passive: true });\n        return () => {\n            wrap.remove();\n            expandWrap.removeEventListener(\"scroll\", onScroll);\n            shrinkWrap.removeEventListener(\"scroll\", onScroll);\n        };\n    }\n    exports.watchNodeResized = watchNodeResized;\n}\n"],["/common/utils","function (exports, require) {\n    function logError(a, b) {\n        outputError(\"error\", a, b);\n    }\n    exports.logError = logError;\n    function logWarn(a, b) {\n        outputError(\"warn\", a, b);\n    }\n    exports.logWarn = logWarn;\n    function outputError(type, a, b) {\n        let err = typeof (a) === \"string\" ? b : a;\n        let pretext = typeof (a) === \"string\" ? a : \"\";\n        let errText;\n        if (err instanceof Error) {\n            errText = (err.stack || err.message || err) + \"\";\n        }\n        else {\n            errText = err + \"\";\n        }\n        console[type](pretext + errText);\n    }\n    function isPathInsidePath(innerPath, outerPath) {\n        let startsWith = innerPath.indexOf(outerPath) === 0;\n        if (!startsWith) {\n            return false;\n        }\n        let nextChar = innerPath.length === outerPath.length ? '' : innerPath.charAt(outerPath.length);\n        let hasPathTerminator = nextChar === '/' || nextChar === '\\\\' || nextChar === '';\n        return hasPathTerminator;\n    }\n    exports.isPathInsidePath = isPathInsidePath;\n    function randomNumberString() {\n        return Math.floor(Math.random() * 0xffffffff) + \"\";\n    }\n    exports.randomNumberString = randomNumberString;\n    function randomUniqId(idObject) {\n        let id;\n        do {\n            id = randomNumberString();\n        } while (id in idObject);\n        return id;\n    }\n    exports.randomUniqId = randomUniqId;\n    function deepEquals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (typeof (a) !== typeof (b)) {\n            return false;\n        }\n        if (typeof (a) === \"object\" && typeof (b) === \"object\" && a && b) {\n            if (Array.isArray(a) || Array.isArray(b)) {\n                if (!Array.isArray(a) || !Array.isArray(b)) {\n                    return false;\n                }\n                if (a.length !== b.length) {\n                    return false;\n                }\n                for (let i = 0; i < a.length; i++) {\n                    if (!deepEquals(a[i], b[i])) {\n                        return false;\n                    }\n                }\n            }\n            else {\n                for (let k in a) {\n                    if (!(k in b) || !deepEquals(a[k], b[k])) {\n                        return false;\n                    }\n                }\n                for (let k in b) {\n                    if (!(k in a)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    exports.deepEquals = deepEquals;\n}\n"]]
,
{"entryPoint":{"module":"/client/client_entrypoint","function":"main"}},eval);