(
function imploderLoader(defs, params, evl) {
    "use strict";
    var req = typeof (require) !== "undefined" ? require : function () { throw new Error("External require() function is not defined! Could not load any external module."); };
    function handleError(e, action) {
        var handler = params.errorHandler;
        if (handler) {
            handler(e, action);
        }
        else {
            console.error((action ? "Error during " + action + ": " : "") + (e.stack || e.message || e));
        }
        throw e;
    }
    // разбираем полученный массив определений
    var renames = {};
    var defMap = {};
    for (var i = 0; i < defs.length; i++) {
        var v = defs[i];
        var m = typeof (v[2]) !== "string" ? v[2] : undefined;
        var def = m ? m : {};
        def.name = v[0];
        def.code = v[v.length - 1];
        if (m && m.altName) {
            renames[m.altName] = def.name;
        }
        def.dependencies = Array.isArray(v[1]) ? v[1] : [];
        defMap[def.name] = def;
    }
    var amd = typeof (define) === "function" && !!define.amd;
    /** функция, которую будут дергать в качестве require изнутри модулей */
    function requireAny(names, onOk, onError) {
        if (!onOk) {
            // дернуты как commonjs, т.е. синхронно с одним именем
            var name_1 = names;
            if (name_1 in defMap) {
                return getProduct(name_1);
            }
            else {
                // тут мы просто надеемся, что человек, который пишет код - не дурак
                // и знает, в каком окружении он будет запускаться
                // и поэтому просто дергаем require как commonjs синхронный require
                return req(name_1);
            }
        }
        else {
            // дернуты как amd
            var callError = function (e) {
                if (onError) {
                    onError(e);
                }
                else {
                    handleError(e);
                }
            };
            try {
                var nameArr = Array.isArray(names) ? names : [names];
                var resultArr_1 = [];
                var nameIndex_1 = {};
                var externalNameArr_1 = nameArr.filter(function (name, index) {
                    nameIndex_1[name] = index;
                    if (name in defMap) {
                        resultArr_1[index] = getProduct(name);
                        return false;
                    }
                    return true;
                });
                if (externalNameArr_1.length === 0) {
                    return onOk.apply(null, resultArr_1);
                }
                else {
                    if (amd) {
                        return req(externalNameArr_1, function (externalResults) {
                            for (var i = 0; i < externalNameArr_1.length; i++) {
                                resultArr_1[nameIndex_1[externalNameArr_1[i]]] = externalResults[i];
                            }
                            onOk.apply(null, resultArr_1);
                        }, onError);
                    }
                    else {
                        // если у нас запросили модули асинхронно, но при этом у нас есть только синрохнный commonjs-овый require - 
                        // то используем его, чего еще делать
                        externalNameArr_1.forEach(function (name) { return resultArr_1[nameIndex_1[name]] = req(name); });
                        onOk.apply(null, resultArr_1);
                    }
                }
            }
            catch (e) {
                callError(e);
            }
        }
    }
    var currentlyDefiningProductMap = {};
    var currentlyDefiningProductSeq = [];
    var products = {};
    function throwCircularDependencyError(name) {
        var str = name;
        for (var i = currentlyDefiningProductSeq.length - 1; i >= 0; i--) {
            var n = currentlyDefiningProductSeq[i];
            str += " <- " + currentlyDefiningProductSeq[i];
            if (n === name)
                break;
        }
        throw new Error("Unresolvable circular dependency detected: " + str);
    }
    function getProduct(name) {
        name = renames[name] || name;
        var meta = defMap[name];
        if (!(name in products)) {
            if (name in currentlyDefiningProductMap) {
                throwCircularDependencyError(name);
            }
            currentlyDefiningProductMap[name] = true;
            currentlyDefiningProductSeq.push(name);
            try {
                var product = {};
                var deps_1 = [product, requireAny];
                meta.dependencies.forEach(function (name) {
                    if (name in renames) {
                        name = renames[name];
                    }
                    var product = products[name];
                    if (product) {
                        deps_1.push(product);
                        return;
                    }
                    var depMeta = defMap[name];
                    if (!depMeta) {
                        throw new Error("Failed to get module \"" + name + "\": no definition is known and no preloaded external module is present.");
                    }
                    deps_1.push(depMeta.arbitraryType || (!depMeta.exports && !depMeta.exportRefs) ? getProduct(name) : getProxy(depMeta));
                });
                var fullCode = meta.code;
                if (meta.nonModule) {
                    fullCode = "function(){" + fullCode + "}";
                }
                fullCode = "'use strict';(" + fullCode + ")\n//# sourceURL=" + meta.name;
                var defFunc = evl(fullCode);
                var returnProduct = defFunc.apply(null, deps_1);
                if (meta.arbitraryType) {
                    product = returnProduct;
                }
                products[name] = product;
            }
            finally {
                delete currentlyDefiningProductMap[name];
                currentlyDefiningProductSeq.pop();
            }
        }
        return products[name];
    }
    var proxies = {};
    function getProxy(def) {
        if (!(def.name in proxies)) {
            var proxy_1 = {};
            getAllExportNames(def).forEach(function (arr) {
                arr.forEach(function (name) {
                    defineProxyProp(def, proxy_1, name);
                });
            });
            proxies[def.name] = proxy_1;
        }
        return proxies[def.name];
    }
    function getAllExportNames(meta, result, noDefault) {
        if (result === void 0) { result = []; }
        if (noDefault === void 0) { noDefault = false; }
        if (meta.exports) {
            if (noDefault) {
                result.push(meta.exports.filter(function (_) { return _ !== "default"; }));
            }
            else {
                result.push(meta.exports);
            }
        }
        if (meta.exportRefs) {
            meta.exportRefs.forEach(function (ref) {
                // тут, теоретически, могла бы возникнуть бесконечная рекурсия
                // но не возникнет, еще при компиляции есть проверка
                if (ref in defMap) {
                    getAllExportNames(defMap[ref], result, true);
                }
                else if (ref in products) {
                    // модуля может не быть, если он внешний и в бандл не вошел
                    result.push(Object.keys(products[ref]));
                }
                else {
                    // такого по идее произойти не должно никогда, т.к. оно упадет раньше
                    // еще на этапе подгрузки внешних модулей
                    throw new Error("External module " + ref + " is not loaded at required time.");
                }
            });
        }
        return result;
    }
    function defineProxyProp(meta, proxy, name) {
        if (proxy.hasOwnProperty(name)) {
            return;
        }
        Object.defineProperty(proxy, name, {
            get: function () { return getProduct(meta.name)[name]; },
            set: function (v) { return getProduct(meta.name)[name] = v; },
            enumerable: true
        });
    }
    function discoverExternalModules(moduleName, result, visited) {
        if (result === void 0) { result = []; }
        if (visited === void 0) { visited = {}; }
        if (moduleName in renames) {
            moduleName = renames[moduleName];
        }
        if (!(moduleName in visited)) {
            visited[moduleName] = true;
            if (moduleName in defMap) {
                defMap[moduleName].dependencies.forEach(function (depName) { return discoverExternalModules(depName, result, visited); });
            }
            else {
                result.push(moduleName);
            }
        }
        return result;
    }
    function afterExternalsLoaded() {
        var mainProduct = getProduct(params.entryPoint.module);
        // инициализируем все модули в бандле, ради сайд-эффектов
        Object.keys(defMap).forEach(function (name) {
            if (!(name in products)) {
                getProduct(name);
            }
        });
        var err = null;
        if (params.entryPoint.function) {
            try {
                mainProduct[params.entryPoint.function].apply(null, params.entryPointArgs || []);
            }
            catch (e) {
                err = e;
            }
        }
        if (err) {
            handleError(err);
        }
        if (typeof (module) === "object" && module.exports) {
            module.exports = mainProduct;
        }
        return mainProduct;
    }
    function start() {
        if (amd) {
            var externalModuleNames_1 = discoverExternalModules(params.entryPoint.module, ["require"]);
            define(externalModuleNames_1, function (require) {
                req = require;
                for (var i = externalModuleNames_1.length; i < arguments.length; i++) {
                    products[externalModuleNames_1[i]] = arguments[i];
                }
                return afterExternalsLoaded();
            });
        }
        else {
            var externalModuleNames_2 = discoverExternalModules(params.entryPoint.module);
            requireAny(externalModuleNames_2, function () {
                for (var i = 0; i < arguments.length; i++) {
                    products[externalModuleNames_2[i]] = arguments[i];
                }
                afterExternalsLoaded();
            });
        }
    }
    start();
})(

[["/client/api_client",["/common/utils"],"function (exports, require, utils_1) {\n    const viewSettingsFilename = \"view_settings.json\";\n    const buildingPlanFilename = \"building_plan.json\";\n    class ApiClient {\n        constructor(apiUrlBase) {\n            this.apiUrlBase = apiUrlBase;\n        }\n        async callApi(name, body = null) {\n            let resp = await fetch(this.apiUrlBase + name, {\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                method: \"POST\",\n                body: JSON.stringify(body)\n            });\n            let result = await resp.json();\n            if (result.ok !== true) {\n                throw new Error(\"Response is not OK\");\n            }\n            return result.result;\n        }\n        async getJson(path) {\n            let resp = await fetch(\"./static/\" + path, { method: \"GET\" });\n            return await resp.json();\n        }\n        saveSettings(filename, settings) {\n            return this.callApi(\"saveSettings\", [filename, settings]);\n        }\n        saveViewSettings(settings) {\n            return this.saveSettings(viewSettingsFilename, settings);\n        }\n        async loadViewSettings() {\n            try {\n                return await this.getJson(viewSettingsFilename);\n            }\n            catch (e) {\n                (0, utils_1.logWarn)(\"Failed to load view settings: \", e);\n                return null;\n            }\n        }\n        saveBuildingPlan(settings) {\n            return this.saveSettings(buildingPlanFilename, settings);\n        }\n        async loadBuildingPlan() {\n            try {\n                return await this.getJson(buildingPlanFilename);\n            }\n            catch (e) {\n                (0, utils_1.logWarn)(\"Failed to load building plan: \", e);\n                return null;\n            }\n        }\n        enumeratePanoramFiles() {\n            return this.callApi(\"enumeratePanoramFiles\");\n        }\n        async canEdit() {\n            try {\n                return this.callApi(\"canEdit\");\n            }\n            catch (e) {\n                (0, utils_1.logWarn)(\"Got error trying to determine if I am allowed to edit. Guess not. \", e);\n                return false;\n            }\n        }\n    }\n    exports.ApiClient = ApiClient;\n}\n"],["/client/app_state",["/client/boundable/boundable"],"function (exports, require, boundable_1) {\n    class AppState {\n        constructor() {\n            this.isPlanActive = (0, boundable_1.boundValue)(false);\n            this.isInEditMode = (0, boundable_1.boundValue)(false);\n            this.selectedFloor = (0, boundable_1.boundValue)(null);\n            this.selectedImage = (0, boundable_1.boundValue)(null);\n            this.hideInactiveFloors = (0, boundable_1.boundValue)(false);\n            this.panoramFsTree = (0, boundable_1.boundValue)([]);\n            this.selectedSceneObject = (0, boundable_1.boundValue)(null);\n            this.isInLinkMode = (0, boundable_1.boundValue)(false);\n            this.selectedLinkType = (0, boundable_1.boundValue)(\"step\");\n            this.currentDisplayedPanoram = (0, boundable_1.boundValue)(null);\n        }\n    }\n    exports.AppState = AppState;\n}\n"],["/client/boundable/boundable","function (exports, require) {\n    function isBoundable(x) {\n        return typeof (x) === \"function\" && (!!x.isBoundValue || !!x.isBoundComputable);\n    }\n    exports.isBoundable = isBoundable;\n    function isBoundValue(x) {\n        return typeof (x) === \"function\" && !!x.isBoundValue;\n    }\n    exports.isBoundValue = isBoundValue;\n    function unwrapBoundable(x) {\n        return isBoundable(x) ? x() : x;\n    }\n    exports.unwrapBoundable = unwrapBoundable;\n    function createSubscribeNotify(getValue) {\n        let subscribers = new Set();\n        return {\n            subscribe: (listener) => {\n                let v = getValue();\n                let sub = { fn: listener, lastKnownValue: v };\n                subscribers.add(sub);\n                return () => subscribers.delete(sub);\n            },\n            notify: () => {\n                let subs = [...subscribers];\n                for (let i = 0; i < subs.length; i++) {\n                    let sub = subs[i];\n                    let v = getValue();\n                    let hasDiff = boundableContentCanBeDifferent(v, sub.lastKnownValue);\n                    sub.lastKnownValue = v;\n                    if (hasDiff) {\n                        sub.fn(v);\n                    }\n                }\n            },\n            subscribers: subscribers\n        };\n    }\n    const notificationStack = [];\n    function withAccessNotifications(action, onAccess) {\n        notificationStack.push(onAccess);\n        let result;\n        try {\n            result = action();\n        }\n        finally {\n            notificationStack.pop();\n        }\n        return result;\n    }\n    function notifyOnAccess(v) {\n        if (notificationStack.length > 0) {\n            notificationStack[notificationStack.length - 1](v);\n        }\n    }\n    function boundableContentCanBeDifferent(oldValue, newValue) {\n        return newValue !== oldValue || (typeof (oldValue) === \"object\" && oldValue !== null);\n    }\n    exports.boundableContentCanBeDifferent = boundableContentCanBeDifferent;\n    function boundValue(x) {\n        let value = x;\n        let getterSetter = function (newValue) {\n            if (arguments.length < 1) {\n                notifyOnAccess(result);\n            }\n            else if (boundableContentCanBeDifferent(value, newValue)) {\n                value = newValue;\n                result.notify();\n            }\n            return value;\n        };\n        let { subscribe, notify } = createSubscribeNotify(() => value);\n        let result = Object.assign(getterSetter, {\n            isBoundValue: true,\n            subscribe: subscribe,\n            notify: notify\n        });\n        return result;\n    }\n    exports.boundValue = boundValue;\n    function computable(computingFn) {\n        let hasComputedValue = false;\n        let value = null;\n        let subDisposers = [];\n        let subDispose = () => {\n            subDisposers.forEach(x => x());\n            subDisposers.length = 0;\n        };\n        let forceRecalculate = () => {\n            hasComputedValue = false;\n            if (subscribers.size !== 0) {\n                computeAndSubscribe();\n            }\n        };\n        let computeAndSubscribe = () => {\n            subDispose();\n            let valuesAccessed = new Set();\n            let newValue = withAccessNotifications(computingFn, boundValue => valuesAccessed.add(boundValue));\n            valuesAccessed.forEach(v => subDisposers.push(v.subscribe(forceRecalculate)));\n            let hasDiff = !hasComputedValue || boundableContentCanBeDifferent(value, newValue);\n            hasComputedValue = true;\n            value = newValue;\n            if (hasDiff) {\n                computable.notify();\n            }\n            return value;\n        };\n        let maybeUnsubscribeFromValues = () => {\n            if (subscribers.size === 0) {\n                hasComputedValue = false;\n                value = null;\n                subDispose();\n            }\n        };\n        let computableFn = () => {\n            notifyOnAccess(computable);\n            if (subscribers.size === 0) {\n                return computingFn();\n            }\n            if (!hasComputedValue) {\n                return computeAndSubscribe();\n            }\n            return value;\n        };\n        let { subscribe, notify, subscribers } = createSubscribeNotify(computableFn);\n        let wrappedSubscribe = (listener) => {\n            if (!hasComputedValue) {\n                computeAndSubscribe();\n            }\n            let disposer = subscribe(listener);\n            return () => {\n                disposer();\n                maybeUnsubscribeFromValues();\n            };\n        };\n        let computable = Object.assign(computableFn, {\n            isBoundComputable: true,\n            subscribe: wrappedSubscribe,\n            notify: notify\n        });\n        return computable;\n    }\n    exports.computable = computable;\n}\n"],["/client/client_entrypoint",["/client/utils/graphic_utils","/client/skybox_controller","/client/context","/client/settings_controller","/client/api_client","/client/planbox_controller","/client/layout_controller","/client/app_state"],"function (exports, require, graphic_utils_1, skybox_controller_1, context_1, settings_controller_1, api_client_1, planbox_controller_1, layout_controller_1, app_state_1) {\n    async function main() {\n        checkWebglVersion(1);\n        let context = new context_1.AppContextImpl();\n        context.api = new api_client_1.ApiClient(\"/api/\");\n        context.state = new app_state_1.AppState();\n        let [viewSettings, plan, canEdit] = await Promise.all([\n            context.api.loadViewSettings(),\n            context.api.loadBuildingPlan(),\n            context.api.canEdit()\n        ]);\n        context.settings = new settings_controller_1.SettingsController(viewSettings, plan, context);\n        context.planbox = new planbox_controller_1.PlanboxController(context);\n        let initialRotation = null;\n        if (context.settings.startPanoram) {\n            let panoramId = context.settings.startPanoram();\n            if (panoramId && context.settings.panorams()[panoramId]) {\n                context.state.currentDisplayedPanoram(panoramId);\n                initialRotation = {\n                    x: context.settings.startPanoramRotX() || 0,\n                    y: context.settings.startPanoramRotY() || 0\n                };\n            }\n        }\n        context.skybox = new skybox_controller_1.SkyboxController(context.settings, context, context.state.currentDisplayedPanoram, initialRotation);\n        context.layout = new layout_controller_1.LayoutController(context, { canEdit, root: document.body });\n        context.layout.start();\n    }\n    exports.main = main;\n    function checkWebglVersion(version) {\n        if ((0, graphic_utils_1.isWebGLAvailable)(version)) {\n            return;\n        }\n        let container = document.getElementById(\"loading-screen\");\n        if (container) {\n            container.appendChild((0, graphic_utils_1.getWebglErrorElement)(version));\n        }\n        throw new Error(\"No webGL, aborted\");\n    }\n}\n"],["/client/context","function (exports, require) {\n    const emptyAppContext = {\n        skybox: null,\n        planbox: null,\n        settings: null,\n        state: null,\n        api: null,\n        layout: null\n    };\n    function wrapWithGetterSetters(names) {\n        let result = class WrappedWithGettersSetters {\n            constructor() {\n                names.forEach(name => {\n                    let value = null;\n                    Object.defineProperty(this, name, {\n                        get: () => {\n                            if (value === null) {\n                                throw new Error(\"No \" + name + \" is defined yet.\");\n                            }\n                            else {\n                                return value;\n                            }\n                        },\n                        set: newValue => {\n                            value = newValue;\n                        }\n                    });\n                });\n            }\n        };\n        return result;\n    }\n    class AppContextImpl extends wrapWithGetterSetters(Object.keys(emptyAppContext)) {\n    }\n    exports.AppContextImpl = AppContextImpl;\n}\n"],["/client/controls/common/button",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1) {\n    function button(options) {\n        let button = (0, dom_utils_1.tag)({});\n        let watch = (0, control_1.makeNodeBoundWatcher)(button);\n        function recalcClass() {\n            button.className = \"button \" +\n                ((0, boundable_1.unwrapBoundable)(options.class) || \"\") + \" \" +\n                ((0, boundable_1.unwrapBoundable)(options.active) ? \"active\" : \"\") + \" \" +\n                ((0, boundable_1.unwrapBoundable)(options.disabled) ? \"disabled\" : \"\");\n        }\n        watch(options.class, recalcClass);\n        watch(options.disabled, recalcClass);\n        watch(options.active, recalcClass);\n        watch(options.text, text => button.textContent = text);\n        let isRunning = false;\n        button.addEventListener(\"click\", async () => {\n            if (isRunning) {\n                return;\n            }\n            isRunning = true;\n            try {\n                await Promise.resolve(options.onclick.call(null));\n            }\n            finally {\n                isRunning = false;\n            }\n        });\n        return { element: button };\n    }\n    exports.button = button;\n}\n"],["/client/controls/common/collapser",["/client/controls/control","/client/utils/dom_utils"],"function (exports, require, control_1, dom_utils_1) {\n    function collapser(options, children) {\n        let header = (0, dom_utils_1.tag)({ class: \"collapser-header\" });\n        let collapser = (0, dom_utils_1.tag)({ class: \"collapser\" }, [header]);\n        let collapsed = true;\n        function updateText() {\n            header.textContent = options.text + \" \" + (collapsed ? \"v\" : \"^\");\n        }\n        header.addEventListener(\"click\", () => {\n            collapsed = !collapsed;\n            if (collapsed) {\n                let childNodes = collapser.childNodes;\n                for (let i = childNodes.length - 1; i >= 0; i--) {\n                    let node = childNodes[i];\n                    if (node !== header) {\n                        node.remove();\n                    }\n                }\n            }\n            else {\n                children.forEach(child => {\n                    let el = (0, dom_utils_1.toHtmlTag)(child);\n                    if (el) {\n                        collapser.appendChild(el);\n                    }\n                });\n            }\n            updateText();\n        });\n        let watch = (0, control_1.makeNodeBoundWatcher)(collapser);\n        watch(options.text, updateText);\n        return collapser;\n    }\n    exports.collapser = collapser;\n}\n"],["/client/controls/common/drop_down_list",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1) {\n    function dropDownList(options) {\n        let select = (0, dom_utils_1.tag)({ tagName: \"select\" });\n        let value = (0, boundable_1.isBoundValue)(options.value) ? options.value : (0, boundable_1.boundValue)(options.value);\n        let watch = (0, control_1.makeNodeBoundWatcher)(select);\n        watch(options.options, newOptValues => {\n            let oldValue = value();\n            select.innerHTML = \"\";\n            let hasValue = false;\n            newOptValues.forEach(option => {\n                hasValue = hasValue || option.value === oldValue;\n                select.appendChild((0, dom_utils_1.tag)({ tagName: \"option\", text: option.label, value: option.value }));\n            });\n            if (hasValue && oldValue !== null) {\n                select.value = oldValue;\n            }\n            else if (newOptValues.length > 0) {\n                select.value = newOptValues[0].value;\n                value(newOptValues[0].value);\n            }\n            else if (oldValue !== null) {\n                select.value = \"\";\n                value(null);\n            }\n        });\n        watch(value, newValue => {\n            select.value = newValue !== null ? newValue : \"\";\n        });\n        select.addEventListener(\"change\", () => value(select.value));\n        return { element: select };\n    }\n    exports.dropDownList = dropDownList;\n}\n"],["/client/controls/common/number_input",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils","/client/utils/number_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1, number_utils_1) {\n    function numberInput(opts) {\n        let optsValue = opts.value || (0, boundable_1.boundValue)(0);\n        let input = (0, dom_utils_1.tag)({\n            tagName: \"input\",\n            type: \"number\",\n            class: \"number-input\"\n        });\n        function getNestedBoundValue() {\n            let nestedValue = optsValue();\n            return (0, boundable_1.isBoundValue)(nestedValue) ? nestedValue : optsValue;\n        }\n        let lastKnownValue = input.value;\n        function onMaybeChange() {\n            if (input.value === lastKnownValue) {\n                return;\n            }\n            lastKnownValue = input.value;\n            let boundValue = getNestedBoundValue();\n            boundValue(parseFloat(input.value || \"0\"));\n        }\n        input.addEventListener(\"change\", onMaybeChange);\n        input.addEventListener(\"keypress\", onMaybeChange);\n        input.addEventListener(\"keydown\", onMaybeChange);\n        input.addEventListener(\"keyup\", onMaybeChange);\n        let watch = (0, control_1.makeNodeBoundWatcher)(input);\n        let onNestedValueChanged = (value) => {\n            input.value = (0, number_utils_1.toFixedNoTrail)(value, 5);\n        };\n        {\n            let nestedValue = optsValue();\n            if ((0, boundable_1.isBoundValue)(nestedValue)) {\n                let clearNestedWatcher = null;\n                watch(optsValue, nestedValue => {\n                    if (clearNestedWatcher) {\n                        clearNestedWatcher();\n                    }\n                    clearNestedWatcher = watch(nestedValue, onNestedValueChanged);\n                });\n            }\n            else {\n                if (!(0, boundable_1.isBoundValue)(optsValue)) {\n                    throw new Error(\"WUT\");\n                }\n                watch(optsValue, onNestedValueChanged);\n            }\n        }\n        watch(opts.disabled, disabled => {\n            input.disabled = disabled;\n        });\n        return {\n            element: input,\n            get value() {\n                return getNestedBoundValue();\n            }\n        };\n    }\n    exports.numberInput = numberInput;\n}\n"],["/client/controls/common/panel",["/client/controls/control","/client/utils/dom_utils"],"function (exports, require, control_1, dom_utils_1) {\n    function panel(opts, children = []) {\n        let hidden = opts.hidden;\n        delete opts.hidden;\n        let panel = (0, dom_utils_1.tag)(opts, children);\n        let watch = (0, control_1.makeNodeBoundWatcher)(panel, { preventDisplayChange: true });\n        watch(hidden, hidden => {\n            panel.style.display = hidden ? \"none\" : \"\";\n        });\n        return panel;\n    }\n    exports.panel = panel;\n}\n"],["/client/controls/common/slider",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils","/client/utils/drag","/client/utils/number_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1, drag_1, number_utils_1) {\n    function slider(options) {\n        let toFixed = (x) => (0, number_utils_1.toFixedNoTrail)(x, options.fractionalPositions || 5);\n        let valueContainer = (0, boundable_1.isBoundValue)(options.value) ? options.value : (0, boundable_1.boundValue)(options.value);\n        let input = (0, dom_utils_1.tag)({ tagName: \"input\", type: \"number\" });\n        input.value = toFixed(valueContainer());\n        let notch = (0, dom_utils_1.tag)({ class: \"slider-notch\", style: \"left: 0\" });\n        let notchContainer = (0, dom_utils_1.tag)({ class: \"slider-notch-container\" }, [notch]);\n        let dragging = false;\n        let oldValue = input.value;\n        function onInputMaybeChanged() {\n            if (dragging) {\n                oldValue = input.value;\n                return;\n            }\n            if (oldValue === input.value) {\n                return;\n            }\n            oldValue = input.value;\n            let value = Math.max(options.min, Math.min(options.max, parseFloat(input.value)));\n            if (options.integer) {\n                value = Math.round(value);\n            }\n            valueContainer(value);\n        }\n        function setNotchPos(value) {\n            notch.style.left = (((value - options.min) / (options.max - options.min)) * 100) + \"%\";\n        }\n        setNotchPos(valueContainer());\n        function setInputValue(value) {\n            if (options.integer) {\n                value = Math.round(value);\n            }\n            input.value = toFixed(value);\n        }\n        input.addEventListener(\"change\", onInputMaybeChanged, { passive: true });\n        input.addEventListener(\"keyup\", onInputMaybeChanged, { passive: true });\n        input.addEventListener(\"keypress\", onInputMaybeChanged, { passive: true });\n        input.addEventListener(\"mouseup\", onInputMaybeChanged, { passive: true });\n        input.addEventListener(\"click\", onInputMaybeChanged, { passive: true });\n        let minX = 0, maxX = 0;\n        (0, drag_1.addDragListeners)({\n            element: notch,\n            onDragStart: () => {\n                let rect = notchContainer.getBoundingClientRect();\n                minX = rect.left;\n                maxX = rect.right;\n                dragging = true;\n            },\n            onDragEnd: () => {\n                dragging = false;\n            },\n            onDrag: ({ x }) => {\n                let percent = Math.max(0, Math.min(1, (x - minX) / (maxX - minX)));\n                let value = options.min + ((options.max - options.min) * percent);\n                valueContainer(value);\n            }\n        });\n        let el = (0, dom_utils_1.tag)({ class: \"slider\" }, [\n            (0, dom_utils_1.tag)({ class: \"slider-top\" }, [\n                (0, dom_utils_1.tag)({ class: \"editor label\", text: options.label }),\n                input,\n                (0, dom_utils_1.tag)({ class: \"slider-units\", text: options.units || \"\" }),\n            ]),\n            (0, dom_utils_1.tag)({ class: \"slider-bottom\" }, [\n                (0, dom_utils_1.tag)({ class: \"slider-min\", text: toFixed(options.min) }),\n                (0, dom_utils_1.tag)({ class: \"slider-notch-container-container\" }, [\n                    notchContainer\n                ]),\n                (0, dom_utils_1.tag)({ class: \"slider-max\", text: toFixed(options.max) })\n            ])\n        ]);\n        let watch = (0, control_1.makeNodeBoundWatcher)(el);\n        watch(valueContainer, newValue => {\n            setNotchPos(newValue);\n            if (input.value !== toFixed(newValue)) {\n                setInputValue(newValue);\n            }\n        });\n        return {\n            element: el,\n            value: valueContainer\n        };\n    }\n    exports.slider = slider;\n}\n"],["/client/controls/common/tree_list",["/client/boundable/boundable","/client/controls/control","/client/utils/dom_utils"],"function (exports, require, boundable_1, control_1, dom_utils_1) {\n    function treeList(options) {\n        let treeListRoot = (0, dom_utils_1.tag)({ class: \"tree-list\" });\n        let itemsByValue = new Map();\n        let value = (0, boundable_1.isBoundValue)(options.value) ? options.value : (0, boundable_1.boundValue)(options.value);\n        function renderItem(item) {\n            let el = (0, dom_utils_1.tag)({\n                class: [\n                    \"tree-list-item\",\n                    item.items ? \"has-children collapsed\" : null,\n                ],\n                text: item.label,\n                style: `margin-left: ${item.depth}em`,\n                \"data-depth\": item.depth\n            });\n            function tryToggleExpanded() {\n                if (item.items) {\n                    el.classList.toggle(\"collapsed\");\n                    el.classList.toggle(\"expanded\");\n                    if (result.expanded) {\n                        while (true) {\n                            let next = el.nextElementSibling;\n                            if (!next) {\n                                break;\n                            }\n                            let depth = parseInt(next.getAttribute(\"data-depth\") || \"0\");\n                            if (depth <= (item.depth || 0)) {\n                                break;\n                            }\n                            next.remove();\n                        }\n                    }\n                    else {\n                        let lastAddedElem = el;\n                        let addAll = (items) => {\n                            items.forEach(item => {\n                                let el = item.element = (item.element || renderItem(item));\n                                lastAddedElem.after(el.element);\n                                lastAddedElem = el.element;\n                                if (item.items && el.expanded) {\n                                    addAll(item.items);\n                                }\n                            });\n                        };\n                        addAll(item.items);\n                    }\n                    result.expanded = !result.expanded;\n                }\n            }\n            el.addEventListener(\"click\", () => {\n                tryToggleExpanded();\n                if (item.value !== undefined) {\n                    value(value() === item.value ? null : item.value);\n                }\n            }, { passive: true });\n            let result = {\n                expanded: false,\n                element: el,\n                toggleExpanded: tryToggleExpanded\n            };\n            return result;\n        }\n        function setItems(newItems) {\n            value(null);\n            treeListRoot.innerHTML = \"\";\n            itemsByValue = new Map();\n            let visit = (newItems, parent, depth = 0) => {\n                newItems.forEach(item => {\n                    item.parent = parent;\n                    item.depth = depth;\n                    if (item.value) {\n                        itemsByValue.set(item.value, item);\n                    }\n                    if (item.items) {\n                        visit(item.items, item, depth + 1);\n                    }\n                });\n            };\n            visit(newItems);\n            newItems.forEach((item) => {\n                let el = item.element = (item.element || renderItem(item));\n                treeListRoot.appendChild(el.element);\n            });\n        }\n        function chainExpand(item) {\n            if (item.parent) {\n                chainExpand(item.parent);\n            }\n            if (!item.items || !item.element || item.element.expanded) {\n                return;\n            }\n            item.element.toggleExpanded();\n        }\n        function toggleSelectionOn(value) {\n            if (value !== null) {\n                let item = itemsByValue.get(value);\n                if (!item) {\n                    return;\n                }\n                chainExpand(item);\n                if (item.element) {\n                    item.element.element.classList.toggle(\"selected\");\n                }\n            }\n        }\n        let watch = (0, control_1.makeNodeBoundWatcher)(treeListRoot);\n        let oldValue = value();\n        watch(value, newValue => {\n            toggleSelectionOn(oldValue);\n            toggleSelectionOn(newValue);\n            oldValue = newValue;\n        });\n        watch(options.items, newItems => setItems(newItems));\n        return { element: treeListRoot };\n    }\n    exports.treeList = treeList;\n}\n"],["/client/controls/composite/plan_edit/plan_edit_controls",["/client/controls/specific/save_button","/client/utils/dom_utils","/client/controls/composite/plan_edit/plan_edit_floor_controls","/client/controls/common/panel","/client/boundable/boundable","/client/controls/composite/plan_edit/plan_edit_file_controls"],"function (exports, require, save_button_1, dom_utils_1, plan_edit_floor_controls_1, panel_1, boundable_1, plan_edit_file_controls_1) {\n    function getPlanEditControls(context) {\n        let result = (0, panel_1.panel)({\n            class: \"plan-edit-controls-container\",\n            hidden: (0, boundable_1.computable)(() => !context.state.isInEditMode() || !context.state.isPlanActive())\n        }, [\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label big\", text: \"Общий план\" }),\n                (0, save_button_1.getSaveButton)(context)\n            ]),\n            ...(0, plan_edit_floor_controls_1.getPlanEditFloorControls)(context),\n            ...(0, plan_edit_file_controls_1.getPlanEditFileControls)(context)\n        ]);\n        return result;\n    }\n    exports.getPlanEditControls = getPlanEditControls;\n}\n"],["/client/controls/composite/plan_edit/plan_edit_file_controls",["/client/utils/dom_utils","/client/boundable/boundable","/client/controls/common/button","/client/controls/common/tree_list","/common/utils","/client/utils/three_global_pos_to_local","/client/controls/common/slider","/client/controls/common/drop_down_list"],"function (exports, require, dom_utils_1, boundable_1, button_1, tree_list_1, utils_1, three_global_pos_to_local_1, slider_1, drop_down_list_1) {\n    function filenameToPanoramId(filename) {\n        return filename.toLowerCase().replace(/\\.[^./\\\\]*$/, \"\");\n    }\n    function fsTreeToTreeListNodes(fsTree) {\n        let treeItems = [];\n        let visit = (node, parentPath) => {\n            var _a;\n            let currentFullPath = (parentPath ? parentPath + \"/\" : \"\") + node.name;\n            let panoramId = node.children ? undefined : filenameToPanoramId(currentFullPath);\n            let label = node.name;\n            if (panoramId) {\n                label = filenameToPanoramId(label);\n            }\n            if (node.dimensions) {\n                label += ` (${node.dimensions.width} x ${node.dimensions.height})`;\n            }\n            return {\n                label: label,\n                items: (_a = node.children) === null || _a === void 0 ? void 0 : _a.map(node => visit(node, currentFullPath)),\n                value: panoramId\n            };\n        };\n        fsTree.forEach(node => {\n            let treeNode = visit(node, \"\");\n            treeItems.push(treeNode);\n        });\n        return treeItems;\n    }\n    function updatePanoramsByFsTree(fsTree, knownPanorams) {\n        let visit = (node, parentPath) => {\n            let currentFullPath = (parentPath ? parentPath + \"/\" : \"\") + node.name;\n            let panoramId = undefined;\n            if (node.children) {\n                node.children.forEach(node => visit(node, currentFullPath));\n            }\n            else {\n                panoramId = filenameToPanoramId(currentFullPath);\n                if (!(panoramId in knownPanorams)) {\n                    knownPanorams[panoramId] = { filename: \"\", label: \"\" };\n                }\n                knownPanorams[panoramId].filename = currentFullPath;\n                knownPanorams[panoramId].label = filenameToPanoramId(node.name);\n            }\n        };\n        fsTree.forEach(node => visit(node, \"\"));\n    }\n    async function loadPanoramsFromFs(context) {\n        try {\n            let fsPanoramTree = await context.api.enumeratePanoramFiles();\n            context.state.panoramFsTree(fsPanoramTree);\n            let knownPanorams = context.settings.panorams();\n            updatePanoramsByFsTree(fsPanoramTree, knownPanorams);\n            context.settings.panorams(knownPanorams);\n        }\n        catch (e) {\n            (0, utils_1.logError)(e);\n        }\n    }\n    function getPlanEditFileControls(context) {\n        let panoramTreeList = (0, tree_list_1.treeList)({\n            value: context.state.selectedImage,\n            items: (0, boundable_1.computable)(() => fsTreeToTreeListNodes(context.state.panoramFsTree()))\n        });\n        loadPanoramsFromFs(context);\n        let addPanoramToFloorButton = (0, button_1.button)({\n            text: \"+\",\n            disabled: (0, boundable_1.computable)(() => {\n                var _a;\n                let panoramId = context.state.selectedImage();\n                let floorId = context.state.selectedFloor();\n                return floorId === null ||\n                    panoramId === null ||\n                    ((_a = context.settings.panorams()[panoramId].position) === null || _a === void 0 ? void 0 : _a.floorId) === floorId;\n            }),\n            onclick: () => {\n                let panoramId = context.state.selectedImage();\n                let floorId = context.state.selectedFloor();\n                if (!panoramId || !floorId) {\n                    return;\n                }\n                let panorams = context.settings.panorams();\n                let panoram = panorams[panoramId];\n                if (!panoram.position) {\n                    panoram.position = { floorId, x: 0, z: 0, rotation: 0 };\n                }\n                else if (panoram.position.floorId !== floorId) {\n                    panoram.position.floorId = floorId;\n                }\n                let selectedObj = context.state.selectedSceneObject();\n                if (selectedObj && selectedObj.type === \"floor\") {\n                    let vec = selectedObj.gizmoPoint.clone();\n                    (0, three_global_pos_to_local_1.movePositionToLocal)(vec, selectedObj.object);\n                    panoram.position.x = vec.x;\n                    panoram.position.z = vec.z;\n                }\n                context.settings.panorams.notify();\n            }\n        });\n        let toggleLinkModeButton = (0, button_1.button)({\n            text: \"Связи\",\n            active: context.state.isInLinkMode,\n            onclick: () => {\n                context.state.isInLinkMode(!context.state.isInLinkMode());\n            }\n        });\n        let linkTypeSelector = (0, drop_down_list_1.dropDownList)({\n            options: [{\n                    value: \"door\",\n                    label: \"Дверь\",\n                }, {\n                    value: \"stairs\",\n                    label: \"Лестница\"\n                }, {\n                    value: \"step\",\n                    label: \"Шаг\"\n                }],\n            value: context.state.selectedLinkType\n        });\n        let removePanoramFromFloorButton = (0, button_1.button)({\n            text: \"-\",\n            disabled: (0, boundable_1.computable)(() => {\n                let panoramId = context.state.selectedImage();\n                let panorams = context.settings.panorams();\n                return panoramId === null || !panorams[panoramId].position;\n            }),\n            onclick: () => {\n                let panoramId = context.state.selectedImage();\n                if (!panoramId) {\n                    return;\n                }\n                let panorams = context.settings.panorams();\n                let panoram = panorams[panoramId];\n                delete panoram.position;\n                delete panoram.links;\n                context.settings.panorams.notify();\n                let selectedObj = context.state.selectedSceneObject();\n                if (selectedObj && selectedObj.type === \"panoram\" && selectedObj.panoramId === panoramId) {\n                    context.state.selectedSceneObject(null);\n                }\n            }\n        });\n        let setImageBeFloorTexture = (0, button_1.button)({\n            text: \"+\",\n            disabled: (0, boundable_1.computable)(() => {\n                let imgId = context.state.selectedImage();\n                let floorId = context.state.selectedFloor();\n                let floors = context.settings.floors();\n                return !imgId || !floorId || floors[floorId].texture === imgId;\n            }),\n            onclick: () => {\n                let imgId = context.state.selectedImage();\n                let floorId = context.state.selectedFloor();\n                if (!imgId || !floorId) {\n                    return;\n                }\n                let floors = context.settings.floors();\n                floors[floorId].texture = imgId;\n                context.settings.floors(floors);\n            }\n        });\n        let clearFloorTexture = (0, button_1.button)({\n            text: \"-\",\n            disabled: (0, boundable_1.computable)(() => {\n                let floorId = context.state.selectedFloor();\n                let floors = context.settings.floors();\n                return !floorId || !floors[floorId].texture;\n            }),\n            onclick: () => {\n                let floorId = context.state.selectedFloor();\n                if (!floorId) {\n                    return;\n                }\n                let floors = context.settings.floors();\n                delete floors[floorId].texture;\n                context.settings.floors(floors);\n            }\n        });\n        let goIntoPanoramButton = (0, button_1.button)({\n            text: \"В панораму\",\n            disabled: (0, boundable_1.computable)(() => {\n                let panoramId = context.state.selectedImage();\n                return !panoramId || !context.settings.panorams()[panoramId].position;\n            }),\n            onclick: () => {\n                let panoramId = context.state.selectedImage();\n                if (panoramId) {\n                    let panoram = context.settings.panorams()[panoramId];\n                    if (panoram.position) {\n                        context.state.currentDisplayedPanoram(panoramId);\n                        context.state.isPlanActive(false);\n                    }\n                }\n            }\n        });\n        let planLabelScaleInput = (0, slider_1.slider)({\n            label: \"Масштаб текста на плане\",\n            value: context.settings.planLabelScale,\n            min: 1 / 200,\n            max: 1 / 10\n        });\n        return [\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label medium\", text: \"Текстура этажа\" }),\n                setImageBeFloorTexture, clearFloorTexture\n            ]),\n            planLabelScaleInput,\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label medium\", text: \"Панорамы\" }),\n                addPanoramToFloorButton, removePanoramFromFloorButton, goIntoPanoramButton\n            ]),\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                toggleLinkModeButton, linkTypeSelector\n            ]),\n            panoramTreeList\n        ];\n    }\n    exports.getPlanEditFileControls = getPlanEditFileControls;\n}\n"],["/client/controls/composite/plan_edit/plan_edit_floor_controls",["/client/boundable/boundable","/client/controls/common/button","/client/controls/common/drop_down_list","/client/controls/common/number_input","/client/controls/control","/common/utils","/client/utils/dom_utils"],"function (exports, require, boundable_1, button_1, drop_down_list_1, number_input_1, control_1, utils_1, dom_utils_1) {\n    function getPlanEditFloorControls(context) {\n        let floorSelector = (0, drop_down_list_1.dropDownList)({\n            options: (0, boundable_1.computable)(() => {\n                let floors = context.settings.floors();\n                return Object.keys(floors)\n                    .map(floorId => {\n                    let floor = floors[floorId];\n                    return { label: floor.label, value: floorId };\n                });\n            }),\n            value: context.state.selectedFloor\n        });\n        let addFloorButton = (0, button_1.button)({\n            text: \"+\",\n            onclick: () => {\n                let floors = context.settings.floors();\n                let id = (0, utils_1.randomUniqId)(floors);\n                let y = -10;\n                for (let floorId in floors) {\n                    y = Math.max(y, floors[floorId].y);\n                }\n                y += 10;\n                let floor = { label: \"Этаж \" + id, x: 0, y, z: 0, width: 10, length: 10, rotation: 0 };\n                floors[id] = (floor);\n                context.settings.floors(floors);\n                context.state.selectedFloor(id);\n            }\n        });\n        let renameFloorButton = (0, button_1.button)({\n            text: \"Имя\",\n            disabled: (0, boundable_1.computable)(() => context.state.selectedFloor() === null),\n            onclick: () => {\n                let floorId = context.state.selectedFloor();\n                if (floorId) {\n                    let newName = prompt(\"Введите имя этажа:\");\n                    if (newName !== null) {\n                        let floors = context.settings.floors();\n                        floors[floorId].label = newName;\n                        context.settings.floors(floors);\n                    }\n                }\n            }\n        });\n        let deleteFloorButton = (0, button_1.button)({\n            text: \"-\",\n            disabled: (0, boundable_1.computable)(() => context.state.selectedFloor() === null),\n            onclick: () => {\n                let floorId = context.state.selectedFloor();\n                if (floorId) {\n                    let floors = context.settings.floors();\n                    delete floors[floorId];\n                    context.settings.floors(floors);\n                }\n            }\n        });\n        let hideInactiveFloorsToggleButton = (0, button_1.button)({\n            text: \"Прятать\",\n            active: context.state.hideInactiveFloors,\n            onclick: () => {\n                context.state.hideInactiveFloors(!context.state.hideInactiveFloors());\n            }\n        });\n        let watch = (0, control_1.makeNodeBoundWatcher)(floorSelector.element);\n        let makeFloorBoundNumberInput = (propName, mult = 1) => {\n            let input = (0, number_input_1.numberInput)({\n                disabled: (0, boundable_1.computable)(() => context.state.selectedFloor() === null)\n            });\n            let lastUpdatedFloorByKey = null;\n            watch(input.value, value => {\n                let floorId = context.state.selectedFloor();\n                if (floorId && floorId === lastUpdatedFloorByKey) {\n                    let floors = context.settings.floors();\n                    floors[floorId][propName] = value / mult;\n                    context.settings.floors(floors);\n                }\n            });\n            watch(context.state.selectedFloor, floorId => {\n                if (!floorId) {\n                    input.value(0);\n                }\n                else {\n                    let floor = context.settings.floors()[floorId];\n                    input.value(floor[propName] * mult);\n                }\n                lastUpdatedFloorByKey = floorId;\n            });\n            return input;\n        };\n        let widthInput = makeFloorBoundNumberInput(\"width\");\n        let lengthInput = makeFloorBoundNumberInput(\"length\");\n        let rotationInput = makeFloorBoundNumberInput(\"rotation\", 180 / Math.PI);\n        return [\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label medium\", text: \"Этаж\" }),\n                addFloorButton, renameFloorButton, deleteFloorButton, hideInactiveFloorsToggleButton\n            ]),\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label editor\", text: \"Ширина\" }),\n                widthInput,\n                (0, dom_utils_1.tag)({ class: \"label editor\", text: \"Длина\" }),\n                lengthInput,\n                (0, dom_utils_1.tag)({ class: \"label editor\", text: \"Поворот\" }),\n                rotationInput\n            ]),\n            floorSelector,\n        ];\n    }\n    exports.getPlanEditFloorControls = getPlanEditFloorControls;\n}\n"],["/client/controls/composite/settings_edit_controls",["/client/controls/common/button","/client/controls/common/collapser","/client/controls/specific/save_button","/client/controls/common/slider","/client/utils/dom_utils","/client/controls/common/panel","/client/boundable/boundable","/client/controls/control"],"function (exports, require, button_1, collapser_1, save_button_1, slider_1, dom_utils_1, panel_1, boundable_1, control_1) {\n    function getSettingsEditControls(context) {\n        let wireframeButton = (0, button_1.button)({\n            text: \"Грани\",\n            onclick: () => context.settings.skyboxWireframe(!context.settings.skyboxWireframe())\n        });\n        let setDefaultPanoramButton = (0, button_1.button)({\n            text: \"Сделать начальной\",\n            active: (0, boundable_1.computable)(() => context.settings.startPanoram() === context.state.currentDisplayedPanoram()),\n            onclick: () => {\n                context.settings.startPanoram(context.state.currentDisplayedPanoram());\n                context.settings.startPanoramRotX(context.skybox.camera.rotation.x);\n                context.settings.startPanoramRotY(context.skybox.camera.rotation.y);\n            }\n        });\n        let panoramRotation = (0, slider_1.slider)({\n            label: \"Поворот\",\n            min: 0,\n            max: 360,\n            value: 0\n        });\n        let result = (0, panel_1.panel)({\n            class: \"settings-edit-controls-container\",\n            hidden: (0, boundable_1.computable)(() => !context.state.isInEditMode() || context.state.isPlanActive())\n        }, [\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                (0, dom_utils_1.tag)({ class: \"label big\", text: \"Настройки\" }),\n                (0, save_button_1.getSaveButton)(context)\n            ]),\n            (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                setDefaultPanoramButton\n            ]),\n            (0, collapser_1.collapser)({ text: \"Камера\" }, [\n                (0, slider_1.slider)({\n                    label: \"FOV\",\n                    min: 30, value: context.settings.fov, max: 180\n                }),\n                (0, slider_1.slider)({\n                    label: \"Мин.наклон\",\n                    min: -Math.PI / 2, value: context.settings.minPitch, max: 0\n                }),\n                (0, slider_1.slider)({\n                    label: \"Макс.наклон\",\n                    min: 0, value: context.settings.maxPitch, max: Math.PI / 2\n                }),\n                (0, slider_1.slider)({\n                    label: \"Высота\",\n                    min: 0, value: context.settings.cameraHeight, max: 2\n                }),\n                (0, slider_1.slider)({\n                    label: \"Скорость поворота\",\n                    min: 1 / 2000, value: context.settings.cameraRotationSpeed, max: 1 / 100\n                })\n            ]),\n            (0, collapser_1.collapser)({ text: \"Skybox\" }, [\n                (0, dom_utils_1.tag)({ class: \"button-toolbar\" }, [\n                    wireframeButton\n                ]),\n                panoramRotation,\n                (0, slider_1.slider)({\n                    label: \"Радиус\", units: \"м\",\n                    min: 0.5, value: context.settings.skyboxRadius, max: 5\n                }),\n                (0, slider_1.slider)({\n                    label: \"Высота\", units: \"м\",\n                    min: 2, value: context.settings.skyboxHeight, max: 10\n                }),\n                (0, slider_1.slider)({\n                    label: \"Боковые сегменты\",\n                    min: 3, value: context.settings.skyboxRadialSegments, max: 512,\n                    integer: true\n                })\n            ]),\n            (0, collapser_1.collapser)({ text: \"Прочее\" }, [\n                (0, slider_1.slider)({\n                    label: \"Размер текста (панорамы)\",\n                    min: 0.001 / 5, value: context.settings.panoramLabelScale, max: 0.001 * 2\n                })\n            ])\n        ]);\n        let watch = (0, control_1.makeNodeBoundWatcher)(setDefaultPanoramButton.element);\n        watch(context.skybox.targetPanoram, panoramId => {\n            if (!panoramId) {\n                return;\n            }\n            let panoram = context.settings.panorams()[panoramId];\n            if (!panoram.position) {\n                return;\n            }\n            panoramRotation.value((panoram.position.rotation * 180) / Math.PI);\n        });\n        watch(panoramRotation.value, rotationGrad => {\n            let panoramId = (0, boundable_1.unwrapBoundable)(context.skybox.targetPanoram);\n            if (!panoramId) {\n                return;\n            }\n            let panoram = context.settings.panorams()[panoramId];\n            if (!panoram.position) {\n                return;\n            }\n            panoram.position.rotation = (rotationGrad / 180) * Math.PI;\n            context.settings.panorams.notify();\n        });\n        return result;\n    }\n    exports.getSettingsEditControls = getSettingsEditControls;\n}\n"],["/client/controls/control",["/client/boundable/boundable","/client/utils/dom_utils","/client/utils/watch_node_inserted_removed"],{"exports":["isControl","makeNodeBoundWatcher"]},"function (exports, require, boundable_1, dom_utils_1, watch_node_inserted_removed_1) {\n    function isControl(x) {\n        return !!x && typeof (x) === \"object\" && x.element instanceof HTMLElement;\n    }\n    exports.isControl = isControl;\n    const emptyValue = {};\n    function makeNodeBoundWatcher(node, opts = {}) {\n        let handlers = [];\n        let inDomNow = (0, dom_utils_1.isInDOM)(node);\n        function onNodeInserted() {\n            (0, watch_node_inserted_removed_1.watchNodeRemoved)(node, onNodeRemoved);\n            for (let i = 0; i < handlers.length; i++) {\n                let handler = handlers[i];\n                handler.clear = handler.boundable.subscribe(handler.handler);\n                let currentValue = handler.boundable();\n                if ((0, boundable_1.boundableContentCanBeDifferent)(handler.lastKnownValue, currentValue)) {\n                    handler.lastKnownValue = currentValue;\n                    handler.handler(currentValue);\n                }\n            }\n            if (!opts.preventDisplayChange) {\n                node.style.display = \"\";\n            }\n        }\n        function onNodeRemoved() {\n            (0, watch_node_inserted_removed_1.watchNodeInserted)(node, onNodeInserted);\n            if (!opts.preventDisplayChange) {\n                node.style.display = \"none\";\n            }\n            for (let i = 0; i < handlers.length; i++) {\n                let handler = handlers[i];\n                if (handler.clear) {\n                    handler.clear();\n                    handler.clear = null;\n                }\n                handler.lastKnownValue = handler.boundable();\n            }\n        }\n        if (inDomNow) {\n            onNodeInserted();\n        }\n        else {\n            onNodeRemoved();\n        }\n        return (boundable, handler) => {\n            if (!(0, boundable_1.isBoundable)(boundable)) {\n                handler(boundable);\n                return () => {\n                };\n            }\n            let obj = {\n                boundable,\n                handler: handler,\n                lastKnownValue: !inDomNow ? emptyValue : boundable(),\n                clear: !inDomNow ? null : boundable.subscribe(handler)\n            };\n            handlers.push(obj);\n            if (inDomNow) {\n                handler(boundable());\n            }\n            return () => {\n                handlers = handlers.filter(x => x !== obj);\n                if (obj.clear) {\n                    obj.clear();\n                    obj.clear = null;\n                }\n            };\n        };\n    }\n    exports.makeNodeBoundWatcher = makeNodeBoundWatcher;\n}\n"],["/client/controls/specific/save_button",["/client/boundable/boundable","/client/controls/common/button"],"function (exports, require, boundable_1, button_1) {\n    function getSaveButton(context) {\n        let saveButton = (0, button_1.button)({\n            disabled: (0, boundable_1.computable)(() => !context.settings.hasUnsavedChanges()),\n            onclick: () => context.settings.save(),\n            text: \"Сохранить\"\n        });\n        return saveButton;\n    }\n    exports.getSaveButton = getSaveButton;\n}\n"],["/client/gizmo_controller",["/client/planbox_controller","/client/scene_controller","/client/threejs_decl","/client/utils/three_global_pos_to_local"],{"exports":["GizmoController"]},"function (exports, require, planbox_controller_1, scene_controller_1, threejs_decl_1, three_global_pos_to_local_1) {\n    const gizmoDistanceScaleMultiplier = 1 / 75;\n    const arrowHeight = 10;\n    const arrowWidth = arrowHeight / 5;\n    const shaftRadius = arrowWidth / 3;\n    const peakHeight = arrowHeight / 5;\n    const cornerSize = arrowHeight / 3;\n    class GizmoController extends scene_controller_1.SceneController {\n        constructor(context) {\n            super(context);\n            this.shaftGeom = new threejs_decl_1.THREE.CylinderGeometry(shaftRadius, shaftRadius, arrowHeight - peakHeight, 6);\n            this.peakGeom = new threejs_decl_1.THREE.ConeGeometry(arrowWidth / 2, peakHeight, 6);\n            this.cornerGeom = new threejs_decl_1.THREE.PlaneGeometry(cornerSize, cornerSize);\n            this.isGizmoMovingNow = false;\n            let { gizmo, arrows, corners } = this.makeGizmo();\n            this.gizmo = gizmo;\n            this.arrows = arrows;\n            this.corners = corners;\n            this.watch(this.context.state.selectedSceneObject, v => this.onSelectedObjectUpdate(v));\n            this.watch(this.context.state.isInEditMode, () => this.onSelectedObjectUpdate());\n            this.watch(this.context.state.isInLinkMode, () => this.onSelectedObjectUpdate());\n        }\n        onSelectedObjectUpdate(v = this.context.state.selectedSceneObject()) {\n            if (v === null || !this.context.state.isInEditMode() || this.context.state.isInLinkMode()) {\n                this.clearGizmo();\n                return;\n            }\n            let distance = this.camera.position.distanceTo(v.gizmoPoint);\n            let scale = distance * gizmoDistanceScaleMultiplier;\n            this.gizmo.scale.x = this.gizmo.scale.y = this.gizmo.scale.z = scale;\n            this.gizmo.position.x = v.gizmoPoint.x;\n            this.gizmo.position.y = v.gizmoPoint.y + scale;\n            this.gizmo.position.z = v.gizmoPoint.z;\n            if (v.parent) {\n                (0, three_global_pos_to_local_1.movePositionToLocal)(this.gizmo.position, v.parent);\n                v.parent.add(this.gizmo);\n            }\n            else {\n                this.scene.add(this.gizmo);\n            }\n            if (v.type === \"link\") {\n                this.gizmo.position.z += 10;\n            }\n            let directions = [\"x\", \"y\", \"z\"];\n            directions.forEach(dir => {\n                var _a, _b;\n                (_a = this.arrows[dir].parent) === null || _a === void 0 ? void 0 : _a.remove(this.arrows[dir]);\n                (_b = this.corners[dir].parent) === null || _b === void 0 ? void 0 : _b.remove(this.corners[dir]);\n            });\n            switch (v.type) {\n                case \"floor\":\n                    directions.forEach(dir => {\n                        this.gizmo.add(this.arrows[dir], this.corners[dir]);\n                    });\n                    break;\n                case \"panoram\":\n                    this.gizmo.add(this.arrows.x);\n                    this.gizmo.add(this.arrows.z);\n                    this.gizmo.add(this.corners.y);\n                    break;\n                case \"link\":\n                    this.gizmo.add(this.arrows.x);\n                    this.gizmo.add(this.arrows.y);\n                    this.gizmo.add(this.corners.z);\n                    break;\n            }\n        }\n        makeArrow(direction) {\n            let material = new threejs_decl_1.THREE.MeshBasicMaterial({\n                color: direction === \"x\" ? \"#f00\" : direction === \"y\" ? \"#00f\" : \"#0f0\",\n                side: threejs_decl_1.THREE.FrontSide\n            });\n            let result = new threejs_decl_1.THREE.Group();\n            let shaft = new threejs_decl_1.THREE.Mesh(this.shaftGeom, material);\n            shaft.name = \"shaft_\" + direction;\n            shaft.position.y = (arrowHeight - peakHeight) / 2;\n            result.add(shaft);\n            let peak = new threejs_decl_1.THREE.Mesh(this.peakGeom, material);\n            peak.name = \"peak_\" + direction;\n            peak.position.y = arrowHeight - (peakHeight / 2);\n            result.add(peak);\n            switch (direction) {\n                case \"x\":\n                    result.rotation.z = -Math.PI / 2;\n                    break;\n                case \"z\":\n                    result.rotation.x = Math.PI / 2;\n                    break;\n            }\n            return result;\n        }\n        makeGizmo() {\n            let arrows = {};\n            let corners = {};\n            let gizmo = new threejs_decl_1.THREE.Group();\n            let makeArrow = (direction) => {\n                let result = this.makeArrow(direction);\n                arrows[direction] = result;\n                gizmo.add(result);\n                if ((0, threejs_decl_1.isInteractiveObject)(result)) {\n                    result.on(\"mousedown\", evt => this.startMovement(evt, [direction]));\n                }\n            };\n            let makeCorner = (direction) => {\n                let material = new threejs_decl_1.THREE.MeshBasicMaterial({\n                    color: direction === \"x\" ? \"#0ff\" : direction === \"y\" ? \"#ff0\" : \"#f0f\",\n                    side: threejs_decl_1.THREE.DoubleSide\n                });\n                let result = new threejs_decl_1.THREE.Mesh(this.cornerGeom, material);\n                result.name = \"corner_\" + direction;\n                let moveDirs;\n                switch (direction) {\n                    case \"x\":\n                        result.rotation.y = Math.PI / 2;\n                        result.position.z += cornerSize / 2;\n                        result.position.y += cornerSize / 2;\n                        moveDirs = [\"y\", \"z\"];\n                        break;\n                    case \"z\":\n                        result.position.y += cornerSize / 2;\n                        result.position.x += cornerSize / 2;\n                        moveDirs = [\"y\", \"x\"];\n                        break;\n                    case \"y\":\n                        result.rotation.x = Math.PI / 2;\n                        result.position.z += cornerSize / 2;\n                        result.position.x += cornerSize / 2;\n                        moveDirs = [\"z\", \"x\"];\n                        break;\n                }\n                corners[direction] = result;\n                gizmo.add(result);\n                if ((0, threejs_decl_1.isInteractiveObject)(result)) {\n                    result.on(\"mousedown\", evt => this.startMovement(evt, moveDirs));\n                }\n            };\n            makeArrow(\"x\");\n            makeArrow(\"y\");\n            makeArrow(\"z\");\n            makeCorner(\"x\");\n            makeCorner(\"y\");\n            makeCorner(\"z\");\n            if ((0, threejs_decl_1.isInteractiveObject)(gizmo)) {\n                gizmo.cursor = \"pointer\";\n            }\n            return { gizmo, arrows, corners };\n        }\n        startMovement(evt, directions) {\n            var _a, _b, _c, _d, _e, _f, _g;\n            let origEvent = evt.data.originalEvent;\n            let startX = 0;\n            let startY = 0;\n            if (origEvent instanceof MouseEvent) {\n                startX = origEvent.clientX;\n                startY = origEvent.clientY;\n            }\n            else if (origEvent instanceof TouchEvent) {\n                let touch = origEvent.touches[0];\n                if (!touch) {\n                    return;\n                }\n                startX = touch.clientX;\n                startY = touch.clientY;\n            }\n            else {\n                return;\n            }\n            let firstIntersect = evt.intersects[0];\n            const movedObject = this.context.state.selectedSceneObject();\n            if (!firstIntersect || !movedObject) {\n                return;\n            }\n            this.isGizmoMovingNow = true;\n            let distanceToIntersection = firstIntersect.distance;\n            let isRadialMovement = movedObject.type === \"link\";\n            let parent = (_a = this.context.state.selectedSceneObject()) === null || _a === void 0 ? void 0 : _a.parent;\n            let camCosX = Math.cos(this.camera.rotation.x - ((_c = (_b = parent === null || parent === void 0 ? void 0 : parent.rotation) === null || _b === void 0 ? void 0 : _b.x) !== null && _c !== void 0 ? _c : 0));\n            let camCosY = Math.cos(this.camera.rotation.y - ((_e = (_d = parent === null || parent === void 0 ? void 0 : parent.rotation) === null || _d === void 0 ? void 0 : _d.y) !== null && _e !== void 0 ? _e : 0));\n            let camSinY = Math.sin(this.camera.rotation.y - ((_g = (_f = parent === null || parent === void 0 ? void 0 : parent.rotation) === null || _f === void 0 ? void 0 : _f.y) !== null && _g !== void 0 ? _g : 0));\n            let vFOV = (this.camera.fov) * (Math.PI / 180);\n            let screenHeight = this.canvas.clientHeight;\n            let screenWidth = this.canvas.clientWidth;\n            let hFOV = Math.atan(Math.tan(vFOV) * this.camera.aspect);\n            let yMult = directions.find(dir => dir === \"y\") ? 0 : 1;\n            let makeOnmoveHandler = (direction) => {\n                let usingRadialFormula = isRadialMovement && direction === \"x\";\n                let startObjValue = usingRadialFormula\n                    ? Math.atan(movedObject.object.position.x / movedObject.object.position.z)\n                    : movedObject.object.position[direction];\n                let gizmoOffset = usingRadialFormula\n                    ? Math.atan(this.gizmo.position.x / this.gizmo.position.z) - startObjValue\n                    : this.gizmo.position[direction] - startObjValue;\n                let minValueLimit = Number.MIN_SAFE_INTEGER;\n                let maxValueLimit = Number.MAX_SAFE_INTEGER;\n                {\n                    let limArray = !movedObject.getLimits ? null : movedObject.getLimits(direction);\n                    if (limArray) {\n                        [minValueLimit, maxValueLimit] = limArray;\n                    }\n                }\n                if (usingRadialFormula) {\n                    if (movedObject.object.position.z < 0) {\n                        startObjValue += Math.PI;\n                    }\n                    let startingRotation = movedObject.object.rotation.y;\n                    let objX = movedObject.object.position.x;\n                    let objZ = movedObject.object.position.z;\n                    let objRadialDistance = Math.sqrt((objX * objX) + (objZ * objZ));\n                    let gizX = this.gizmo.position.x;\n                    let gizZ = this.gizmo.position.z;\n                    let gizmoRadialDistance = Math.sqrt((gizX * gizX) + (gizZ * gizZ));\n                    return (x, y) => {\n                        void y;\n                        let dAngle = hFOV * (startX - x) / screenWidth;\n                        movedObject.object.position.x = objRadialDistance * Math.sin(startObjValue + dAngle);\n                        movedObject.object.position.z = objRadialDistance * Math.cos(startObjValue + dAngle);\n                        movedObject.object.rotation.y = startingRotation + dAngle;\n                        if (movedObject.object !== movedObject.parent) {\n                            this.gizmo.position.x = gizmoRadialDistance * Math.sin(startObjValue + gizmoOffset + dAngle);\n                            this.gizmo.position.y = gizmoRadialDistance * Math.sin(startObjValue + gizmoOffset + dAngle);\n                        }\n                    };\n                }\n                else {\n                    return (x, y) => {\n                        let dx = startX - x;\n                        let dy = startY - y;\n                        let dVal;\n                        switch (direction) {\n                            case \"y\": {\n                                let dPx = (dy * camCosX);\n                                let dAngle = (vFOV * (dPx / screenHeight));\n                                dVal = distanceToIntersection * Math.tan(dAngle);\n                                break;\n                            }\n                            case \"x\": {\n                                let dPx = (-dx * camCosY) + (-dy * camSinY * yMult);\n                                let dAngle = hFOV * (dPx / screenWidth);\n                                dVal = distanceToIntersection * Math.tan(dAngle);\n                                break;\n                            }\n                            case \"z\":\n                                {\n                                    let dPx = (dx * camSinY) + (-dy * camCosY * yMult);\n                                    let dAngle = hFOV * (dPx / screenWidth);\n                                    dVal = distanceToIntersection * Math.tan(dAngle);\n                                }\n                                break;\n                        }\n                        movedObject.object.position[direction] = Math.max(minValueLimit, Math.min(maxValueLimit, startObjValue + dVal));\n                        if (movedObject.object !== movedObject.parent) {\n                            this.gizmo.position[direction] = movedObject.object.position[direction] + gizmoOffset;\n                        }\n                        if (movedObject.links) {\n                            for (let i = 0; i < movedObject.links.length; i++) {\n                                let link = movedObject.links[i];\n                                this.calcAndSetRotationScaleForLinkLine(link.a, link.b, link.link);\n                            }\n                        }\n                    };\n                }\n            };\n            let onMoveHandlers = directions.map(dir => makeOnmoveHandler(dir));\n            let onMove = (x, y) => {\n                for (let i = 0; i < onMoveHandlers.length; i++) {\n                    onMoveHandlers[i](x, y);\n                }\n            };\n            let onMouseMove = (e) => {\n                onMove(e.clientX, e.clientY);\n            };\n            let onTouchMove = (e) => {\n                let touch = e.touches[0];\n                if (touch) {\n                    onMove(touch.clientX, touch.clientY);\n                }\n            };\n            let onMovementFinish = () => {\n                window.removeEventListener(\"mousemove\", onMouseMove);\n                window.removeEventListener(\"touchmove\", onTouchMove);\n                window.removeEventListener(\"touchend\", onMovementFinish);\n                window.removeEventListener(\"mouseup\", onMovementFinish);\n                this.onMovementFinished();\n            };\n            window.addEventListener(\"mousemove\", onMouseMove);\n            window.addEventListener(\"touchmove\", onTouchMove);\n            window.addEventListener(\"touchend\", onMovementFinish);\n            window.addEventListener(\"mouseup\", onMovementFinish);\n        }\n        onMovementFinished() {\n            var _a;\n            setTimeout(() => {\n                this.isGizmoMovingNow = false;\n            }, 25);\n            const obj = this.context.state.selectedSceneObject();\n            if (obj) {\n                obj.gizmoPoint = this.gizmo.position;\n                switch (obj.type) {\n                    case \"floor\": {\n                        let floor = this.context.settings.floors()[obj.floorId];\n                        floor.x = obj.object.position.x;\n                        floor.y = obj.object.position.y - planbox_controller_1.floorYOffset;\n                        floor.z = obj.object.position.z;\n                        this.context.settings.floors.notify();\n                        break;\n                    }\n                    case \"panoram\": {\n                        let panoram = this.context.settings.panorams()[obj.panoramId];\n                        if (panoram.position) {\n                            panoram.position.x = obj.object.position.x;\n                            panoram.position.z = obj.object.position.z;\n                        }\n                        this.context.settings.panorams.notify();\n                        break;\n                    }\n                    case \"link\": {\n                        let panoram = this.context.settings.panorams()[obj.fromPanoramId];\n                        let link = (_a = panoram.links) === null || _a === void 0 ? void 0 : _a.find(link => link.panoramId === obj.toPanoramId);\n                        if (link) {\n                            let x = obj.object.position.x;\n                            let z = obj.object.position.z;\n                            let radians = Math.atan(x / z);\n                            if (z < 0) {\n                                radians += Math.PI;\n                            }\n                            link.x = radians / (Math.PI * 2);\n                            link.y = (obj.object.position.y / 1000) / this.context.settings.skyboxHeight();\n                            this.context.settings.panorams.notify();\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        addGizmoHandlers(targetObject, onSelect) {\n            if (!(0, threejs_decl_1.isInteractiveObject)(targetObject)) {\n                return;\n            }\n            targetObject.on(\"click\", clickEvent => {\n                if (!this.context.state.isInEditMode() || this.context.state.isInLinkMode() || this.isGizmoMovingNow) {\n                    return;\n                }\n                const intersection = clickEvent.intersects.sort((a, b) => a.distance - b.distance)[0];\n                if (!intersection) {\n                    this.clearGizmo();\n                    return;\n                }\n                onSelect(intersection.point);\n            });\n        }\n        clearGizmo() {\n            if (this.gizmo.parent) {\n                this.gizmo.parent.remove(this.gizmo);\n            }\n        }\n        calcAndSetRotationScaleForLinkLine(a, b, lineMesh) {\n            let posA = new threejs_decl_1.THREE.Vector3();\n            a.getWorldPosition(posA);\n            let posB = new threejs_decl_1.THREE.Vector3();\n            b.getWorldPosition(posB);\n            lineMesh.position.x = (posA.x + posB.x) / 2;\n            lineMesh.position.y = ((posA.y + posB.y) / 2) - 0.35;\n            lineMesh.position.z = (posA.z + posB.z) / 2;\n            lineMesh.scale.y = posA.distanceTo(posB);\n            let dx = posA.x - posB.x;\n            let dz = posA.z - posB.z;\n            let dy = posA.y - posB.y;\n            lineMesh.rotation.z = Math.atan((Math.sqrt((dx * dx) + (dz * dz)) * (dx >= 0 ? 1 : -1)) / dy);\n            lineMesh.rotation.y = Math.atan(-dz / dx) + Math.PI;\n        }\n    }\n    exports.GizmoController = GizmoController;\n}\n"],["/client/keyboard_camera_movement","function (exports, require) {\n    function setupKeyboardCameraMovement(camera, speed) {\n        let directMovement = 0;\n        let strafeMovement = 0;\n        let yMovement = 0;\n        let shouldHandle = () => {\n            if (document.activeElement) {\n                let name = document.activeElement.tagName.toUpperCase();\n                if (name === \"INPUT\" || name === \"SELECT\") {\n                    return false;\n                }\n            }\n            return true;\n        };\n        let handleKeydown = (e) => {\n            if (!shouldHandle()) {\n                return;\n            }\n            switch (e.key.toLowerCase()) {\n                case \"a\":\n                    strafeMovement = -1;\n                    break;\n                case \"d\":\n                    strafeMovement = +1;\n                    break;\n                case \"s\":\n                    directMovement = -1;\n                    break;\n                case \"w\":\n                    directMovement = +1;\n                    break;\n                case \"shift\":\n                    yMovement = -1;\n                    break;\n                case \" \":\n                    yMovement = +1;\n                    break;\n            }\n        };\n        let handleKeyup = (e) => {\n            if (!shouldHandle()) {\n                return;\n            }\n            switch (e.key.toLowerCase()) {\n                case \"a\":\n                    if (strafeMovement === -1) {\n                        strafeMovement = 0;\n                    }\n                    break;\n                case \"d\":\n                    if (strafeMovement === +1) {\n                        strafeMovement = 0;\n                    }\n                    break;\n                case \"s\":\n                    if (directMovement === -1) {\n                        directMovement = 0;\n                    }\n                    break;\n                case \"w\":\n                    if (directMovement === +1) {\n                        directMovement = 0;\n                    }\n                    break;\n                case \"shift\":\n                    if (yMovement === -1) {\n                        yMovement = 0;\n                    }\n                    break;\n                case \" \":\n                    if (yMovement === +1) {\n                        yMovement = 0;\n                    }\n                    break;\n            }\n        };\n        window.addEventListener(\"keydown\", handleKeydown);\n        window.addEventListener(\"keyup\", handleKeyup);\n        return {\n            clear() {\n                window.removeEventListener(\"keydown\", handleKeydown);\n                window.removeEventListener(\"keyup\", handleKeyup);\n            },\n            onFrame(timePassed) {\n                if (yMovement) {\n                    camera.position.y += yMovement * speed * timePassed;\n                }\n                if (directMovement || strafeMovement) {\n                    let direct = directMovement * speed * timePassed;\n                    let strafe = strafeMovement * speed * timePassed;\n                    let sin = Math.sin(camera.rotation.y);\n                    let cos = Math.cos(camera.rotation.y);\n                    camera.position.x -= (sin * direct) - (cos * strafe);\n                    camera.position.z -= (cos * direct) + (sin * strafe);\n                }\n            }\n        };\n    }\n    exports.setupKeyboardCameraMovement = setupKeyboardCameraMovement;\n}\n"],["/client/layout_controller",["/client/controls/common/button","/client/utils/dom_utils","/client/controls/common/panel","/client/controls/control","/client/controls/composite/settings_edit_controls","/client/controls/composite/plan_edit/plan_edit_controls"],"function (exports, require, button_1, dom_utils_1, panel_1, control_1, settings_edit_controls_1, plan_edit_controls_1) {\n    class LayoutController {\n        constructor(context, options) {\n            this.context = context;\n            this.options = options;\n            this.planboxContainer = (0, dom_utils_1.tag)({ class: \"planbox-container-nested\" });\n            this.planRoot = (0, dom_utils_1.tag)({ class: \"planbox-container\" }, [this.planboxContainer]);\n            this.skyboxContainer = (0, panel_1.panel)({ class: \"skybox-container\" });\n        }\n        start() {\n            this.options.root.appendChild(this.planRoot);\n            this.options.root.appendChild(this.skyboxContainer);\n            this.options.root.appendChild((0, dom_utils_1.tag)({ class: \"view-control-buttons-container\" }, [\n                !this.options.canEdit ? null : (0, button_1.button)({\n                    text: \"Редактирование\",\n                    active: this.context.state.isInEditMode,\n                    onclick: () => this.context.state.isInEditMode(!this.context.state.isInEditMode())\n                }),\n                (0, button_1.button)({\n                    text: \"План\",\n                    active: this.context.state.isPlanActive,\n                    onclick: () => this.context.state.isPlanActive(!this.context.state.isPlanActive())\n                })\n            ]));\n            this.options.root.appendChild((0, settings_edit_controls_1.getSettingsEditControls)(this.context));\n            this.planRoot.insertBefore((0, plan_edit_controls_1.getPlanEditControls)(this.context), this.planboxContainer);\n            let watch = (0, control_1.makeNodeBoundWatcher)(this.options.root);\n            watch(this.context.state.isPlanActive, isPlan => {\n                this.planRoot.style.display = isPlan ? \"\" : \"none\";\n                this.skyboxContainer.style.display = isPlan ? \"none\" : \"\";\n                if (isPlan) {\n                    this.context.skybox.stop();\n                    if (!this.context.planbox.isActive) {\n                        this.context.planbox.start(this.planboxContainer);\n                    }\n                }\n                else {\n                    this.context.planbox.stop();\n                    if (!this.context.skybox.isActive) {\n                        this.context.skybox.start(this.skyboxContainer);\n                    }\n                }\n            });\n            this.removeLoadingScreen();\n        }\n        removeLoadingScreen() {\n            let loadingScreen = document.getElementById(\"loading-screen\");\n            if (loadingScreen) {\n                loadingScreen.remove();\n            }\n        }\n    }\n    exports.LayoutController = LayoutController;\n}\n"],["/client/planbox_controller",["/client/keyboard_camera_movement","/client/threejs_decl","/client/settings_controller","/client/skybox_controller"],{"exports":["PlanboxController","floorYOffset"]},"function (exports, require, keyboard_camera_movement_1, threejs_decl_1, settings_controller_1, skybox_controller_1) {\n    exports.floorYOffset = 1000;\n    const linkRadius = 0.25;\n    class PlanboxController extends skybox_controller_1.SkyboxController {\n        constructor(context) {\n            super(context.settings.clone({\n                ...settings_controller_1.defaultViewSettings,\n                fov: context.settings.fov(),\n                skyboxHeight: 2,\n                skyboxRadialSegments: 4\n            }), context);\n            this.keyboardCameraControls = null;\n            this.floors = {};\n            this.panorams = {};\n            this.linkLineMaterial = new threejs_decl_1.THREE.MeshBasicMaterial({ color: \"#FFAE00\", side: threejs_decl_1.THREE.FrontSide });\n            this.linkLineGeometry = new threejs_decl_1.THREE.CylinderGeometry(linkRadius, linkRadius, 1, 4);\n            this.linkSelectStartPanoramId = null;\n            new threejs_decl_1.THREE.Interaction(this.renderer, this.scene, this.camera);\n            this.camera.position.x = 100;\n            this.camera.position.z = 100;\n            this.camera.position.y = 1100;\n            this.camera.lookAt(0, 1000, 0);\n            this.watch(context.settings.floors, floors => this.updateFloors(floors));\n            this.watch(context.settings.panorams, panorams => this.updatePanorams(panorams));\n            this.linkStates();\n        }\n        stop() {\n            super.stop();\n            if (this.keyboardCameraControls) {\n                this.keyboardCameraControls.clear();\n                this.keyboardCameraControls = null;\n            }\n            for (let floorId in this.floors) {\n                let obj = this.floors[floorId];\n                this.scene.remove(obj.mesh);\n                obj.geometry.dispose();\n            }\n        }\n        start(el) {\n            super.start(el);\n            this.keyboardCameraControls = (0, keyboard_camera_movement_1.setupKeyboardCameraMovement)(this.camera, 0.05);\n        }\n        onFrame(timePassed) {\n            super.onFrame(timePassed);\n            if (this.keyboardCameraControls) {\n                this.keyboardCameraControls.onFrame(timePassed);\n            }\n        }\n        updateCamera() {\n        }\n        createUpdateFloorObject(floor, floorId, oldFloorObject) {\n            let geometry = null;\n            if (oldFloorObject) {\n                if (oldFloorObject.width === floor.width && oldFloorObject.length === floor.length) {\n                    geometry = oldFloorObject.geometry;\n                }\n                else {\n                    oldFloorObject.geometry.dispose();\n                }\n            }\n            if (!geometry) {\n                geometry = new threejs_decl_1.THREE.PlaneGeometry(floor.width, floor.length);\n            }\n            let textureImageId = undefined;\n            let material = null;\n            if (oldFloorObject) {\n                if (oldFloorObject.textureImageId === floor.texture) {\n                    textureImageId = oldFloorObject.textureImageId;\n                    material = oldFloorObject.material;\n                }\n                else {\n                    oldFloorObject.material.dispose();\n                    if (oldFloorObject.textureImageId) {\n                        this.textureRepo.unrefTextureByImageId(oldFloorObject.textureImageId);\n                    }\n                }\n            }\n            if (!material) {\n                if (floor.texture) {\n                    textureImageId = floor.texture;\n                    material = new threejs_decl_1.THREE.MeshBasicMaterial({\n                        map: this.textureRepo.imageIdToTexture(floor.texture),\n                        side: threejs_decl_1.THREE.DoubleSide,\n                        transparent: true\n                    });\n                }\n                else {\n                    material = new threejs_decl_1.THREE.MeshBasicMaterial({\n                        color: \"#aaa\",\n                        side: threejs_decl_1.THREE.DoubleSide\n                    });\n                }\n            }\n            let group;\n            if (oldFloorObject) {\n                group = oldFloorObject.group;\n            }\n            else {\n                group = new threejs_decl_1.THREE.Group();\n            }\n            group.position.x = floor.x;\n            group.position.y = floor.y + exports.floorYOffset;\n            group.position.z = floor.z;\n            group.rotation.y = floor.rotation;\n            let obj;\n            if (oldFloorObject) {\n                obj = oldFloorObject.mesh;\n            }\n            else {\n                obj = new threejs_decl_1.THREE.Mesh();\n                obj.name = \"floor_\" + floorId;\n                group.add(obj);\n                this.addGizmoHandlers(obj, point => this.selectFloor(floorId, point));\n            }\n            obj.geometry = geometry;\n            obj.material = material;\n            obj.rotation.x = Math.PI / 2;\n            let result = Object.assign(oldFloorObject || {}, {\n                geometry,\n                mesh: obj,\n                group,\n                material,\n                textureImageId: textureImageId,\n                width: floor.width,\n                length: floor.length\n            });\n            return result;\n        }\n        disposePanoramObject(panoramId) {\n            let panoramObject = this.panorams[panoramId];\n            let panorams = this.context.settings.panorams();\n            let panoram = panorams[panoramId];\n            panoramObject.geometry.dispose();\n            panoramObject.material.dispose();\n            this.textureRepo.unrefTextTexture(panoramObject.label);\n            if (panoramObject.mesh.parent) {\n                panoramObject.mesh.parent.remove(panoramObject.mesh);\n            }\n            delete panoram.position;\n            delete panoram.links;\n            for (let otherPanoramId in panoramObject.links) {\n                let mesh = panoramObject.links[otherPanoramId].mesh;\n                if (mesh.parent) {\n                    mesh.parent.remove(mesh);\n                }\n                delete this.panorams[otherPanoramId].links[panoramId];\n                let otherPanoram = panorams[otherPanoramId];\n                if (otherPanoram.links) {\n                    otherPanoram.links = otherPanoram.links.filter(x => x.panoramId !== panoramId);\n                    if (otherPanoram.links.length === 0) {\n                        delete otherPanoram.links;\n                    }\n                }\n            }\n            delete this.panorams[panoramId];\n        }\n        updateFloors(floors) {\n            for (let floorId in this.floors) {\n                let obj = this.floors[floorId];\n                if (!(floorId in floors)) {\n                    delete this.floors[floorId];\n                    this.scene.remove(obj.group);\n                    obj.geometry.dispose();\n                    if (obj.textureImageId) {\n                        this.textureRepo.unrefTextureByImageId(obj.textureImageId);\n                    }\n                    obj.material.dispose();\n                }\n            }\n            for (let panoramId in this.panorams) {\n                if (!(this.panorams[panoramId].floorId in this.floors)) {\n                    this.disposePanoramObject(panoramId);\n                }\n            }\n            for (let floorId in floors) {\n                let floor = floors[floorId];\n                if (floorId in this.floors) {\n                    this.createUpdateFloorObject(floor, floorId, this.floors[floorId]);\n                }\n                else {\n                    let obj = this.createUpdateFloorObject(floor, floorId);\n                    this.scene.add(obj.group);\n                    this.floors[floorId] = obj;\n                }\n            }\n            this.forEachLink(linkObj => this.calcAndSetRotationScaleForLinkLine(this.panorams[linkObj.fromId].mesh, this.panorams[linkObj.toId].mesh, linkObj.mesh));\n        }\n        makePanoramMaterialGeometry(text) {\n            let texture = this.textureRepo.textToTexture(text);\n            let material = new threejs_decl_1.THREE.MeshBasicMaterial({ map: texture.texture, side: threejs_decl_1.THREE.FrontSide });\n            let geometry = new threejs_decl_1.THREE.PlaneGeometry(texture.width * this.context.settings.planLabelScale(), texture.height * this.context.settings.planLabelScale());\n            return { material, geometry };\n        }\n        createUpdatePanoramObject(panoram, panoramId, floorId, oldPanoramObject) {\n            if (!panoram.position) {\n                throw new Error(\"Could not add panoram: no position\");\n            }\n            let mesh = null;\n            let material = null;\n            let geometry = null;\n            let label = null;\n            if (oldPanoramObject) {\n                mesh = oldPanoramObject.mesh;\n                if (oldPanoramObject.label === panoram.label) {\n                    material = oldPanoramObject.material;\n                    geometry = oldPanoramObject.geometry;\n                    label = oldPanoramObject.label;\n                }\n                else {\n                    oldPanoramObject.material.dispose();\n                    oldPanoramObject.geometry.dispose();\n                    this.textureRepo.unrefTextTexture(oldPanoramObject.label);\n                }\n            }\n            if (!mesh) {\n                mesh = new threejs_decl_1.THREE.Mesh();\n                this.addLinkageHandlers(mesh, panoramId);\n                this.addGizmoHandlers(mesh, point => this.selectPanoram(panoramId, point));\n            }\n            if (!label || !material || !geometry) {\n                label = panoram.label;\n                let mg = this.makePanoramMaterialGeometry(label);\n                mesh.geometry = geometry = mg.geometry;\n                mesh.material = material = mg.material;\n            }\n            mesh.name = \"panoram_\" + panoramId;\n            mesh.rotation.x = -Math.PI / 2;\n            mesh.position.x = panoram.position.x;\n            mesh.position.z = panoram.position.z;\n            mesh.position.y = 0.35;\n            let resultFloorId = null;\n            if (oldPanoramObject) {\n                if (oldPanoramObject.floorId !== floorId) {\n                    let floor = this.floors[oldPanoramObject.floorId];\n                    if (floor) {\n                        floor.group.remove(mesh);\n                    }\n                }\n                else {\n                    resultFloorId = oldPanoramObject.floorId;\n                }\n            }\n            if (!resultFloorId) {\n                resultFloorId = floorId;\n                let floor = this.floors[floorId];\n                floor.group.add(mesh);\n            }\n            let oldLinkObjects = (oldPanoramObject === null || oldPanoramObject === void 0 ? void 0 : oldPanoramObject.links) || {};\n            let linkObjects = {};\n            if (oldPanoramObject) {\n                oldPanoramObject.links = linkObjects;\n            }\n            (panoram.links || []).forEach(link => {\n                if (link.panoramId in oldLinkObjects) {\n                    linkObjects[link.panoramId] = oldLinkObjects[link.panoramId];\n                }\n                else {\n                    if (link.panoramId in this.panorams && mesh) {\n                        let newLink = this.makeLinkObject(mesh, panoramId, this.panorams[link.panoramId].mesh, link.panoramId);\n                        linkObjects[link.panoramId] = newLink;\n                        this.panorams[link.panoramId].links[panoramId] = newLink;\n                        this.scene.add(newLink.mesh);\n                    }\n                }\n            });\n            for (let otherPanoramId in oldLinkObjects) {\n                if (!(otherPanoramId in linkObjects)) {\n                    let oldLinkObject = oldLinkObjects[otherPanoramId];\n                    if (oldLinkObject.mesh.parent) {\n                        oldLinkObject.mesh.parent.remove(oldLinkObject.mesh);\n                    }\n                    delete oldLinkObjects[otherPanoramId];\n                    delete this.panorams[otherPanoramId].links[panoramId];\n                }\n            }\n            let result = Object.assign(oldPanoramObject || {}, {\n                mesh,\n                floorId: resultFloorId,\n                material, geometry, label,\n                links: linkObjects\n            });\n            return result;\n        }\n        makeLinkObject(fromPanoramMesh, fromPanoramId, toPanoramMesh, toPanoramId) {\n            let mesh = new threejs_decl_1.THREE.Mesh(this.linkLineGeometry, this.linkLineMaterial);\n            this.calcAndSetRotationScaleForLinkLine(fromPanoramMesh, toPanoramMesh, mesh);\n            return {\n                fromId: fromPanoramId,\n                toId: toPanoramId,\n                mesh\n            };\n        }\n        addLinkageHandlers(mesh, panoramId) {\n            if (!(0, threejs_decl_1.isInteractiveObject)(mesh)) {\n                return;\n            }\n            mesh.on(\"mousedown\", () => {\n                if (!this.context.state.isInLinkMode() || !this.context.state.isInEditMode()) {\n                    return;\n                }\n                this.linkSelectStartPanoramId = panoramId;\n            });\n            mesh.on(\"mouseup\", () => {\n                if (!this.context.state.isInLinkMode() || !this.context.state.isInEditMode() || !this.linkSelectStartPanoramId) {\n                    return;\n                }\n                let fromId = this.linkSelectStartPanoramId;\n                let toId = panoramId;\n                this.linkSelectStartPanoramId = null;\n                if (fromId === toId) {\n                    return;\n                }\n                let existingLink = this.panorams[fromId].links[toId];\n                let panorams = this.context.settings.panorams();\n                let toLinks = panorams[toId].links || [];\n                let fromLinks = panorams[fromId].links || [];\n                if (existingLink) {\n                    toLinks = toLinks.filter(x => x.panoramId !== fromId);\n                    fromLinks = fromLinks.filter(x => x.panoramId !== toId);\n                }\n                else {\n                    toLinks.push({\n                        panoramId: fromId,\n                        type: this.context.state.selectedLinkType(),\n                        x: Math.random(),\n                        y: 0.5\n                    });\n                    fromLinks.push({\n                        panoramId: toId,\n                        type: this.context.state.selectedLinkType(),\n                        x: Math.random(),\n                        y: 0.5\n                    });\n                }\n                panorams[toId].links = toLinks.length === 0 ? undefined : toLinks;\n                panorams[fromId].links = fromLinks.length === 0 ? undefined : fromLinks;\n                this.context.settings.panorams.notify();\n            });\n        }\n        updatePanorams(panorams) {\n            for (let panoramId in this.panorams) {\n                if (!(panoramId in panorams) || !panorams[panoramId].position) {\n                    this.disposePanoramObject(panoramId);\n                }\n            }\n            for (let panoramId in panorams) {\n                let panoram = panorams[panoramId];\n                if (!panoram.position) {\n                    continue;\n                }\n                this.panorams[panoramId] = this.createUpdatePanoramObject(panoram, panoramId, panoram.position.floorId, this.panorams[panoramId]);\n            }\n        }\n        selectPanoram(panoramId, point) {\n            let selectedObj = this.context.state.selectedSceneObject();\n            if (selectedObj && selectedObj.type === \"panoram\" && selectedObj.panoramId === panoramId) {\n                return;\n            }\n            let { floorId, mesh, links } = this.panorams[panoramId];\n            let floorGroup = this.floors[floorId].group;\n            if (!point) {\n                point = new threejs_decl_1.THREE.Vector3();\n                mesh.getWorldPosition(point);\n            }\n            let relatedLinks = Object.keys(links).map(otherPanoramId => {\n                return { a: mesh, b: this.panorams[otherPanoramId].mesh, link: links[otherPanoramId].mesh };\n            });\n            this.context.state.selectedSceneObject({\n                type: \"panoram\",\n                object: mesh,\n                gizmoPoint: point,\n                panoramId: panoramId,\n                parent: floorGroup,\n                getLimits: dir => this.getPanoramMovementLimits(dir, panoramId),\n                links: relatedLinks\n            });\n        }\n        selectFloor(floorId, point) {\n            let floorObj = this.floors[floorId];\n            this.context.state.selectedSceneObject({\n                type: \"floor\",\n                floorId: floorId,\n                gizmoPoint: point || floorObj.group.position,\n                object: floorObj.group,\n                links: this.getFloorRelatedLinks(floorId).map(linkObj => ({\n                    a: this.panorams[linkObj.fromId].mesh,\n                    b: this.panorams[linkObj.toId].mesh,\n                    link: linkObj.mesh\n                }))\n            });\n        }\n        getPanoramMovementLimits(direction, panoramId) {\n            if (direction === \"y\") {\n                return null;\n            }\n            let floor = this.floors[this.panorams[panoramId].floorId];\n            return direction === \"x\" ? [-floor.width / 2, floor.width / 2] : [-floor.length / 2, floor.length / 2];\n        }\n        getFloorRelatedLinks(floorId) {\n            let result = [];\n            for (let panoramId in this.panorams) {\n                let panoramObject = this.panorams[panoramId];\n                if (panoramObject.floorId === floorId) {\n                    for (let otherPanoramId in panoramObject.links) {\n                        result.push(panoramObject.links[otherPanoramId]);\n                    }\n                }\n            }\n            return result;\n        }\n        forEachLink(handler) {\n            for (let panoramId in this.panorams) {\n                let panoramObject = this.panorams[panoramId];\n                for (let otherPanoramId in panoramObject.links) {\n                    handler(panoramObject.links[otherPanoramId]);\n                }\n            }\n        }\n        linkStates() {\n            this.watch(this.context.state.selectedSceneObject, v => {\n                if (!v) {\n                    this.context.state.selectedImage(null);\n                }\n                else if (v.type === \"panoram\") {\n                    let panoram = this.context.settings.panorams()[v.panoramId];\n                    if (panoram.position) {\n                        this.context.state.selectedFloor(panoram.position.floorId);\n                    }\n                    this.context.state.selectedImage(v.panoramId);\n                }\n                else if (v.type === \"floor\") {\n                    this.context.state.selectedFloor(v.floorId);\n                    this.context.state.selectedImage(null);\n                }\n            });\n            this.watch(this.context.state.selectedFloor, floorId => {\n                if (this.context.state.hideInactiveFloors()) {\n                    for (let otherFloorId in this.floors) {\n                        let group = this.floors[otherFloorId].group;\n                        if (otherFloorId !== floorId && group.parent) {\n                            group.parent.remove(group);\n                        }\n                    }\n                    this.forEachLink(linkObj => {\n                        if (linkObj.mesh.parent) {\n                            linkObj.mesh.parent.remove(linkObj.mesh);\n                        }\n                    });\n                    if (floorId) {\n                        let currentFloorGroup = this.floors[floorId].group;\n                        if (!currentFloorGroup.parent) {\n                            this.scene.add(currentFloorGroup);\n                        }\n                        this.getFloorRelatedLinks(floorId).forEach(linkObject => {\n                            this.scene.add(linkObject.mesh);\n                        });\n                    }\n                }\n                let selectedObj = this.context.state.selectedSceneObject();\n                if (selectedObj && (selectedObj.type !== \"floor\" || selectedObj.floorId === floorId)) {\n                    return;\n                }\n                if (!floorId) {\n                    this.context.state.selectedSceneObject(null);\n                    return;\n                }\n                this.selectFloor(floorId);\n            });\n            this.watch(this.context.state.selectedImage, panoramId => {\n                let selectedObj = this.context.state.selectedSceneObject();\n                if (!panoramId) {\n                    if (selectedObj && selectedObj.type === \"panoram\") {\n                        this.context.state.selectedSceneObject(null);\n                    }\n                    return;\n                }\n                let panoram = this.context.settings.panorams()[panoramId];\n                if (!panoram.position) {\n                    if (selectedObj && selectedObj.type === \"panoram\") {\n                        this.context.state.selectedSceneObject(null);\n                    }\n                    return;\n                }\n                else {\n                    this.selectPanoram(panoramId);\n                }\n            });\n            this.watch(this.context.settings.panorams, () => {\n                let panoramId = this.context.state.selectedImage();\n                if (!panoramId) {\n                    return;\n                }\n                let panoram = this.context.settings.panorams()[panoramId];\n                if (!panoram.position) {\n                    return;\n                }\n                let selectedObj = this.context.state.selectedSceneObject();\n                if (!selectedObj || (selectedObj.type === \"floor\" && selectedObj.floorId === panoram.position.floorId)) {\n                    this.selectPanoram(panoramId);\n                }\n            });\n            this.watch(this.context.settings.planLabelScale, () => {\n                for (let panoramId in this.panorams) {\n                    let p = this.panorams[panoramId];\n                    p.material.dispose();\n                    p.geometry.dispose();\n                    let mg = this.makePanoramMaterialGeometry(p.label);\n                    p.mesh.material = p.material = mg.material;\n                    p.mesh.geometry = p.geometry = mg.geometry;\n                }\n            });\n            this.watch(this.context.state.hideInactiveFloors, doHide => {\n                let selectedFloorId = this.context.state.selectedFloor();\n                if (!selectedFloorId) {\n                    return;\n                }\n                for (let floorId in this.floors) {\n                    if (floorId === selectedFloorId) {\n                        continue;\n                    }\n                    let floorObj = this.floors[floorId];\n                    if (!floorObj.group.parent && !doHide) {\n                        this.scene.add(floorObj.group);\n                    }\n                    else if (floorObj.group.parent && doHide) {\n                        floorObj.group.parent.remove(floorObj.group);\n                    }\n                }\n                let floorRelatedLinks = new Set(this.getFloorRelatedLinks(selectedFloorId));\n                this.forEachLink(linkObject => {\n                    if (floorRelatedLinks.has(linkObject)) {\n                        if (!linkObject.mesh.parent) {\n                            this.scene.add(linkObject.mesh);\n                        }\n                    }\n                    else {\n                        if (doHide && linkObject.mesh.parent) {\n                            linkObject.mesh.parent.remove(linkObject.mesh);\n                        }\n                        else if (!doHide && !linkObject.mesh.parent) {\n                            this.scene.add(linkObject.mesh);\n                        }\n                    }\n                });\n            });\n        }\n        shouldShowCompassOnEdit() {\n            return false;\n        }\n    }\n    exports.PlanboxController = PlanboxController;\n}\n"],["/client/scene_controller",["/client/threejs_decl","/client/texture_repo","/client/controls/control","/client/utils/watch_node_resized","/client/utils/graphic_utils"],"function (exports, require, threejs_decl_1, texture_repo_1, control_1, watch_node_resized_1, graphic_utils_1) {\n    class SceneController {\n        constructor(context) {\n            this.context = context;\n            this.scene = new threejs_decl_1.THREE.Scene();\n            this.camera = new threejs_decl_1.THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);\n            this.renderer = new threejs_decl_1.THREE.WebGLRenderer();\n            this.stopRaf = null;\n            this.stopResizeWatch = null;\n            this.textureRepo = new texture_repo_1.TextureRepository(this.context, {\n                textBgColor: \"#444\",\n                textFgColor: \"#ccc\",\n                textHeight: 64,\n                textMargin: 15\n            });\n            this.watch = (0, control_1.makeNodeBoundWatcher)(this.canvas);\n        }\n        get canvas() {\n            return this.renderer.domElement;\n        }\n        onResize(container) {\n            let w = container.clientWidth;\n            let h = container.clientHeight;\n            this.renderer.setSize(w, h);\n            this.camera.aspect = w / h;\n            this.camera.updateProjectionMatrix();\n        }\n        start(container) {\n            if (this.stopRaf) {\n                throw new Error(\"Already running\");\n            }\n            this.onResize(container);\n            container.appendChild(this.canvas);\n            this.stopRaf = (0, graphic_utils_1.raf)(timePassed => {\n                this.renderer.render(this.scene, this.camera);\n                this.onFrame(timePassed);\n            });\n            this.stopResizeWatch = (0, watch_node_resized_1.watchNodeResized)(container, () => this.onResize(container));\n        }\n        stop() {\n            if (this.stopRaf) {\n                this.stopRaf();\n                this.stopRaf = null;\n            }\n            if (this.stopResizeWatch) {\n                this.stopResizeWatch();\n                this.stopResizeWatch = null;\n            }\n            this.canvas.remove();\n        }\n        onFrame(timePassed) {\n            void timePassed;\n        }\n        get isActive() {\n            return !!this.stopRaf;\n        }\n    }\n    exports.SceneController = SceneController;\n}\n"],["/client/settings_controller",["/client/boundable/boundable"],"function (exports, require, boundable_1) {\n    exports.defaultViewSettings = {\n        cameraHeight: 1.8,\n        fov: 75,\n        maxPitch: Math.PI / 2,\n        minPitch: -(Math.PI / 2),\n        skyboxHeight: 3.5,\n        skyboxRadius: 1.5,\n        skyboxWireframe: false,\n        skyboxRadialSegments: 64,\n        cameraRotationSpeed: 1 / 350,\n        planLabelScale: 1 / 20,\n        panoramLabelScale: 1 / 100\n    };\n    const defaultBuildPlan = {\n        panorams: {},\n        floors: {},\n        startPanoram: null,\n        startPanoramRotX: null,\n        startPanoramRotY: null\n    };\n    const defaultSettingsPack = {\n        ...exports.defaultViewSettings,\n        ...defaultBuildPlan\n    };\n    function wrapWithBoundables(defaultValues) {\n        let result = class WrappedWithBoundables {\n            constructor() {\n                let that = this;\n                Object.keys(defaultValues).forEach(key => {\n                    that[key] = (0, boundable_1.boundValue)(defaultValues[key]);\n                });\n            }\n            setToValues(values) {\n                let that = this;\n                Object.keys(values).forEach(key => {\n                    if (!(0, boundable_1.isBoundValue)(that[key])) {\n                        console.warn(\"Cannot assign value of \" + key + \": unknown key\");\n                    }\n                    else {\n                        that[key](values[key]);\n                    }\n                });\n            }\n            extractByKeys(keys) {\n                let that = this;\n                let result = {};\n                keys.forEach(key => result[key] = that[key]());\n                return result;\n            }\n        };\n        return result;\n    }\n    class SettingsController extends wrapWithBoundables(defaultSettingsPack) {\n        constructor(viewSettings, plan, context) {\n            super();\n            this.context = context;\n            this.hasUnsavedChanges = (0, boundable_1.boundValue)(false);\n            if (viewSettings) {\n                this.setToValues(viewSettings);\n            }\n            if (plan) {\n                this.setToValues(plan);\n            }\n            Object.keys(defaultSettingsPack).forEach(key => {\n                this[key].subscribe(() => this.hasUnsavedChanges(true));\n            });\n        }\n        clone(viewSettings = null, plan = null) {\n            return new SettingsController({\n                ...this.viewSettings,\n                ...(viewSettings || {})\n            }, {\n                ...this.buildingPlan,\n                ...(plan || {})\n            }, this.context);\n        }\n        get viewSettings() {\n            return this.extractByKeys(Object.keys(exports.defaultViewSettings));\n        }\n        get buildingPlan() {\n            return this.extractByKeys(Object.keys(defaultBuildPlan));\n        }\n        async save() {\n            let buildingPlan = this.buildingPlan;\n            let panorams = { ...buildingPlan.panorams };\n            for (let panoramId in panorams) {\n                let panoram = panorams[panoramId];\n                if (!panoram.links && !panoram.position) {\n                    delete panorams[panoramId];\n                }\n            }\n            buildingPlan.panorams = panorams;\n            await Promise.all([\n                this.context.api.saveViewSettings(this.viewSettings),\n                this.context.api.saveBuildingPlan(buildingPlan)\n            ]);\n            this.hasUnsavedChanges(false);\n        }\n    }\n    exports.SettingsController = SettingsController;\n}\n"],["/client/skybox_controller",["/client/boundable/boundable","/client/gizmo_controller","/client/threejs_decl","/client/utils/drag"],{"exports":["SkyboxController"]},"function (exports, require, boundable_1, gizmo_controller_1, threejs_decl_1, drag_1) {\n    const defaultSkyboxPath = \"./static/default_skybox.png\";\n    class SkyboxController extends gizmo_controller_1.GizmoController {\n        constructor(settings, context, targetPanoram = null, initialCameraRotation = null) {\n            super(context);\n            this.settings = settings;\n            this.targetPanoram = targetPanoram;\n            this.currentSkyboxTextureId = null;\n            this.currentSkyboxMaterial = null;\n            this.linkObjects = {};\n            new threejs_decl_1.THREE.Interaction(this.renderer, this.scene, this.camera);\n            let { object, geometry } = this.createSkybox();\n            this.skyboxGroup = new threejs_decl_1.THREE.Group();\n            this.skyboxGroup.name = \"skybox_group\";\n            this.currentSkyboxObject = object;\n            this.currentSkyboxGeometry = geometry;\n            this.skyboxGroup.add(object);\n            this.scene.add(this.skyboxGroup);\n            this.camera.fov = this.settings.fov();\n            this.camera.rotation.order = \"ZYX\";\n            this.camera.position.set(0, this.settings.cameraHeight() * 1000, 0);\n            if (initialCameraRotation) {\n                this.camera.rotation.x = initialCameraRotation.x;\n                this.camera.rotation.y = initialCameraRotation.y;\n            }\n            else {\n                this.camera.lookAt(1, this.settings.cameraHeight() * 1000, 0);\n            }\n            [settings.fov, settings.cameraHeight, settings.minPitch, settings.maxPitch]\n                .forEach(boundable => {\n                this.watch(boundable, () => this.updateCamera());\n            });\n            [settings.skyboxHeight, settings.skyboxRadius, settings.skyboxWireframe, settings.skyboxRadialSegments]\n                .forEach((boundable) => {\n                this.watch(boundable, () => {\n                    this.updateSkyboxShape();\n                    this.updateLinkObjects();\n                });\n            });\n            this.watch(this.targetPanoram, () => {\n                this.updateSkyboxTexture();\n                for (let panoramId in this.linkObjects) {\n                    this.deleteLinkObject(this.linkObjects[panoramId]);\n                }\n                this.linkObjects = {};\n                this.updateLinkObjects();\n            });\n            [settings.panorams, settings.panoramLabelScale].forEach((boundable) => {\n                this.watch(boundable, () => {\n                    this.updateLinkObjects();\n                    this.updatePanoramRotation();\n                });\n            });\n            let compass = this.makeArrow(\"x\");\n            compass.position.x = 0;\n            compass.position.y = 0;\n            compass.position.z = 0;\n            compass.scale.x = compass.scale.y = compass.scale.z = 100;\n            this.watch(context.state.isInEditMode, isEditing => {\n                var _a;\n                if (isEditing && this.shouldShowCompassOnEdit()) {\n                    if (!compass.parent) {\n                        this.scene.add(compass);\n                    }\n                }\n                else {\n                    (_a = compass.parent) === null || _a === void 0 ? void 0 : _a.remove(compass);\n                }\n            });\n            this.setupUserControls();\n        }\n        setupUserControls() {\n            (0, drag_1.addDragListeners)({\n                element: this.canvas,\n                rightMouseButton: true,\n                lockPointer: true,\n                onDrag: ({ dx, dy, source }) => {\n                    if (source === \"touch\") {\n                        dx *= -1;\n                        dy *= -1;\n                    }\n                    this.rotateCamera(dx, dy);\n                },\n                onDragStart: () => {\n                    let focused = document.activeElement;\n                    if (focused && focused instanceof HTMLElement) {\n                        focused.blur();\n                    }\n                }\n            });\n        }\n        createSkybox() {\n            let { geometry, object } = this.createSkyboxObject();\n            return { object, geometry };\n        }\n        createUpdateLinkObject(link, panoramId, linkObject) {\n            let label = null;\n            let texture = null;\n            let material = null;\n            let labelFromData = this.settings.panorams()[link.panoramId].label;\n            if (linkObject) {\n                if (linkObject.label === labelFromData) {\n                    label = labelFromData;\n                    texture = this.textureRepo.textToTexture(linkObject.label, true);\n                    material = linkObject.material;\n                }\n                else {\n                    this.textureRepo.unrefTextTexture(linkObject.label);\n                    linkObject.material.dispose();\n                }\n            }\n            if (!label || !texture || !material) {\n                label = labelFromData;\n                texture = this.textureRepo.textToTexture(label);\n                material = new threejs_decl_1.THREE.MeshBasicMaterial({ map: texture.texture, side: threejs_decl_1.THREE.DoubleSide });\n            }\n            let geometry = null;\n            let scale = null;\n            let scaleFromData = this.context.settings.panoramLabelScale();\n            if (linkObject) {\n                if (linkObject.label === labelFromData && linkObject.scale === scaleFromData) {\n                    scale = scaleFromData;\n                    geometry = linkObject.geometry;\n                }\n                else {\n                    linkObject.geometry.dispose();\n                }\n            }\n            if (!scale || !geometry) {\n                scale = scaleFromData;\n                geometry = new threejs_decl_1.THREE.PlaneGeometry(texture.width * this.context.settings.panoramLabelScale() * 1000, texture.height * this.context.settings.panoramLabelScale() * 1000);\n            }\n            let mesh;\n            if (linkObject) {\n                mesh = linkObject.mesh;\n            }\n            else {\n                mesh = new threejs_decl_1.THREE.Mesh;\n            }\n            mesh.geometry = geometry;\n            mesh.material = material;\n            let group;\n            if (linkObject) {\n                group = linkObject.group;\n            }\n            else {\n                group = new threejs_decl_1.THREE.Group();\n                group.name = \"link_to_\" + link.panoramId + \"_group\";\n                group.add(mesh);\n                if ((0, threejs_decl_1.isInteractiveObject)(group)) {\n                    group.cursor = \"pointer\";\n                    group.on(\"click\", evt => {\n                        if (this.context.state.isInEditMode()) {\n                            if (this.isGizmoMovingNow) {\n                                return;\n                            }\n                            this.context.state.selectedSceneObject({\n                                type: \"link\",\n                                fromPanoramId: panoramId,\n                                toPanoramId: link.panoramId,\n                                gizmoPoint: evt.intersects[0].point,\n                                object: group,\n                                parent: group,\n                                getLimits: (dir) => dir !== \"y\" ? null : [0, this.settings.skyboxHeight() * 1000]\n                            });\n                        }\n                        else {\n                            this.context.state.currentDisplayedPanoram(link.panoramId);\n                        }\n                    });\n                }\n                this.skyboxGroup.add(group);\n            }\n            let radians = link.x * Math.PI * 2;\n            let distance = this.context.settings.skyboxRadius() * 0.9;\n            group.position.x = Math.sin(radians) * distance * 1000;\n            group.position.z = Math.cos(radians) * distance * 1000;\n            group.position.y = link.y * this.context.settings.skyboxHeight() * 1000;\n            group.rotation.y = radians + Math.PI;\n            this.linkObjects[link.panoramId] = { geometry, material, group, label, scale, mesh };\n        }\n        deleteLinkObject(link) {\n            var _a;\n            (_a = link.group.parent) === null || _a === void 0 ? void 0 : _a.remove(link.group);\n            link.material.dispose();\n            link.geometry.dispose();\n            this.textureRepo.unrefTextTexture(link.label);\n        }\n        updateLinkObjects() {\n            var _a;\n            const panoramId = (0, boundable_1.unwrapBoundable)(this.targetPanoram);\n            let knownLinks = new Set();\n            if (panoramId) {\n                let panorams = this.context.settings.panorams();\n                let panoram = panorams[panoramId];\n                (_a = panoram.links) === null || _a === void 0 ? void 0 : _a.forEach(link => {\n                    knownLinks.add(link.panoramId);\n                    this.createUpdateLinkObject(link, panoramId, this.linkObjects[link.panoramId]);\n                });\n            }\n            for (let otherPanoramId in this.linkObjects) {\n                if (!knownLinks.has(otherPanoramId)) {\n                    this.deleteLinkObject(this.linkObjects[otherPanoramId]);\n                    delete this.linkObjects[otherPanoramId];\n                }\n            }\n        }\n        updateSkyboxTexture() {\n            if (this.currentSkyboxMaterial) {\n                if (this.currentSkyboxTextureId) {\n                    this.textureRepo.unrefTextureByImageId(this.currentSkyboxTextureId);\n                }\n                else {\n                    this.textureRepo.unrefTextureByPath(defaultSkyboxPath);\n                }\n                this.currentSkyboxMaterial.dispose();\n            }\n            this.currentSkyboxTextureId = (0, boundable_1.unwrapBoundable)(this.targetPanoram);\n            let texture = this.currentSkyboxTextureId\n                ? this.textureRepo.imageIdToTexture(this.currentSkyboxTextureId)\n                : this.textureRepo.pathToTexture(defaultSkyboxPath);\n            this.currentSkyboxMaterial = new threejs_decl_1.THREE.MeshBasicMaterial({ map: texture, side: threejs_decl_1.THREE.BackSide });\n            if (this.currentSkyboxObject) {\n                this.currentSkyboxObject.material = this.currentSkyboxMaterial;\n            }\n        }\n        createSkyboxObject() {\n            let geometry = new threejs_decl_1.THREE.CylinderGeometry(this.settings.skyboxRadius() * 1000, this.settings.skyboxRadius() * 1000, this.settings.skyboxHeight() * 1000, this.settings.skyboxRadialSegments());\n            patchCylinderUV(geometry);\n            let object;\n            if (this.settings.skyboxWireframe()) {\n                object = new threejs_decl_1.THREE.Line(geometry);\n            }\n            else {\n                object = new threejs_decl_1.THREE.Mesh(geometry);\n            }\n            object.name = \"skybox\";\n            if (this.currentSkyboxMaterial) {\n                object.material = this.currentSkyboxMaterial;\n            }\n            object.position.y = (this.settings.skyboxHeight() / 2) * 1000;\n            if ((0, threejs_decl_1.isInteractiveObject)(object)) {\n                object.on(\"click\", () => {\n                    if (!this.isGizmoMovingNow) {\n                        this.context.state.selectedSceneObject(null);\n                        this.clearGizmo();\n                    }\n                });\n            }\n            return { geometry, object };\n        }\n        clampPitch(pitch) {\n            return Math.max(this.settings.minPitch(), Math.min(this.settings.maxPitch(), pitch));\n        }\n        rotateCamera(dx, dy) {\n            let pitch = this.camera.rotation.x + (dy * this.settings.cameraRotationSpeed());\n            this.camera.rotation.x = this.clampPitch(pitch);\n            this.camera.rotation.y += dx * this.settings.cameraRotationSpeed();\n        }\n        updateSkyboxShape() {\n            var _a;\n            let { geometry, object } = this.createSkyboxObject();\n            this.skyboxGroup.add(object);\n            if (this.currentSkyboxObject) {\n                (_a = this.currentSkyboxObject.parent) === null || _a === void 0 ? void 0 : _a.remove(this.currentSkyboxObject);\n            }\n            if (this.currentSkyboxGeometry) {\n                this.currentSkyboxGeometry.dispose();\n            }\n            this.currentSkyboxObject = object;\n            this.currentSkyboxGeometry = geometry;\n        }\n        updateCamera() {\n            this.camera.fov = this.settings.fov();\n            this.camera.position.y = this.settings.cameraHeight() * 1000;\n            this.camera.rotation.x = this.clampPitch(this.camera.rotation.x);\n            this.camera.updateProjectionMatrix();\n        }\n        shouldShowCompassOnEdit() {\n            return true;\n        }\n        updatePanoramRotation() {\n            let panoramId = (0, boundable_1.unwrapBoundable)(this.targetPanoram);\n            if (!panoramId) {\n                return;\n            }\n            let panoram = this.context.settings.panorams()[panoramId];\n            if (!panoram.position) {\n                return;\n            }\n            this.skyboxGroup.rotation.y = panoram.position.rotation;\n        }\n    }\n    exports.SkyboxController = SkyboxController;\n    function patchCylinderUV(geom) {\n        let cylinderSideUVs = new Map();\n        let pos = geom.attributes.position;\n        let uv = geom.attributes.uv;\n        let norm = geom.attributes.normal;\n        function makePosKey(i) {\n            return pos.getX(i).toFixed(3) + \"|\" + pos.getY(i).toFixed(3) + \"|\" + pos.getZ(i).toFixed(3);\n        }\n        for (let i = 0; i < uv.count; i++) {\n            let normY = norm.getY(i);\n            if (normY < 0.0001 && normY > -0.0001) {\n                cylinderSideUVs.set(makePosKey(i), { x: uv.getX(i), y: uv.getY(i) });\n            }\n        }\n        let sideCount = (uv.count - 4) / 6;\n        let topCenterVertexIndexStart = (sideCount * 2) + 2;\n        let bottomCenterVertexIndexStart = (sideCount * 4) + 3;\n        for (let i = 0; i < uv.count; i++) {\n            let normY = norm.getY(i);\n            if (normY > 0.0001 || normY < -0.0001) {\n                let posX = pos.getX(i), posZ = pos.getZ(i);\n                if (posX < 0.0001 && posX > -0.0001 && posZ < 0.0001 && posZ > -0.0001) {\n                    let isTop = normY > 0;\n                    let indexStart = isTop ? topCenterVertexIndexStart : bottomCenterVertexIndexStart;\n                    let offset = ((i - indexStart) + 0.5) / sideCount;\n                    uv.setX(i, offset);\n                    uv.setY(i, isTop ? 1 : 0);\n                }\n                else {\n                    let goodUV = cylinderSideUVs.get(makePosKey(i));\n                    if (goodUV) {\n                        uv.setX(i, goodUV.x);\n                        uv.setY(i, goodUV.y);\n                    }\n                    else {\n                        console.warn(`Found NO good UV for position ${pos.getX(i)},${pos.getY(i)},${pos.getZ(i)}`);\n                    }\n                }\n            }\n        }\n        uv.needsUpdate = true;\n    }\n}\n"],["/client/texture_repo",["/client/threejs_decl","/client/utils/three_text_render"],"function (exports, require, threejs_decl_1, three_text_render_1) {\n    class TextureRepository {\n        constructor(context, options) {\n            this.context = context;\n            this.options = options;\n            this.textureLoader = new threejs_decl_1.THREE.TextureLoader();\n            this.imageTextures = {};\n            this.textTextures = {};\n            this.imageCleanupList = new Set();\n            this.textCleanupList = new Set();\n            this.cleanupHandler = null;\n        }\n        pathToTexture(path) {\n            if (!this.imageTextures[path]) {\n                this.imageTextures[path] = {\n                    texture: this.textureLoader.load(path),\n                    refCount: 1\n                };\n            }\n            else {\n                this.imageTextures[path].refCount++;\n            }\n            return this.imageTextures[path].texture;\n        }\n        imageIdToPath(imageId) {\n            let panorams = this.context.settings.panorams();\n            let panoram = panorams[imageId];\n            return \"./img/\" + panoram.filename;\n        }\n        imageIdToTexture(imageId) {\n            return this.pathToTexture(this.imageIdToPath(imageId));\n        }\n        unrefTextureByImageId(imageId) {\n            this.unrefTextureByPath(this.imageIdToPath(imageId));\n        }\n        unrefTextureByPath(path) {\n            let descr = this.imageTextures[path];\n            descr.refCount--;\n            if (descr.refCount < 1) {\n                this.imageCleanupList.add(path);\n                this.initCleanup();\n            }\n        }\n        textToTexture(text, skipReferenceIncrement = false) {\n            if (!this.textTextures[text]) {\n                this.textTextures[text] = {\n                    rendered: (0, three_text_render_1.renderTextToTexture)(text, this.options.textHeight, this.options.textMargin, this.options.textMargin, this.options.textFgColor, this.options.textBgColor),\n                    refCount: 1\n                };\n            }\n            else {\n                if (!skipReferenceIncrement) {\n                    this.textTextures[text].refCount++;\n                }\n            }\n            return this.textTextures[text].rendered;\n        }\n        unrefTextTexture(text) {\n            let descr = this.textTextures[text];\n            descr.refCount--;\n            if (descr.refCount < 1) {\n                this.textCleanupList.add(text);\n                this.initCleanup();\n            }\n        }\n        initCleanup() {\n            if (!this.cleanupHandler) {\n                this.cleanupHandler = setTimeout(() => {\n                    this.cleanupHandler = null;\n                    this.imageCleanupList.forEach(path => {\n                        let item = this.imageTextures[path];\n                        if (item.refCount === 0) {\n                            delete this.imageTextures[path];\n                            item.texture.dispose();\n                        }\n                    });\n                    this.imageCleanupList.clear();\n                    this.textCleanupList.forEach(text => {\n                        let item = this.textTextures[text];\n                        if (item.refCount === 0) {\n                            delete this.textTextures[text];\n                            item.rendered.texture.dispose();\n                        }\n                    });\n                    this.textCleanupList.clear();\n                }, 1000);\n            }\n        }\n    }\n    exports.TextureRepository = TextureRepository;\n}\n"],["/client/threejs_decl","function (exports, require) {\n    exports.THREE = window.THREE;\n    function isInteractiveObject(x) {\n        return typeof (x.on) === \"function\";\n    }\n    exports.isInteractiveObject = isInteractiveObject;\n    var InteractionLib;\n    (function (InteractionLib) {\n    })(InteractionLib = exports.InteractionLib || (exports.InteractionLib = {}));\n}\n"],["/client/utils/dom_utils",["/client/controls/control"],{"exports":["isInDOM","tag","toHtmlTag"]},"function (exports, require, control_1) {\n    function tag(a, b) {\n        let description;\n        let children = undefined;\n        if (!a) {\n            description = {};\n            children = b || undefined;\n        }\n        else {\n            if (Array.isArray(a)) {\n                description = {};\n                children = a;\n            }\n            else {\n                description = a;\n                children = b || undefined;\n            }\n        }\n        let res = document.createElement(description.tagName || \"div\");\n        for (let k in description) {\n            let v = description[k];\n            switch (k) {\n                case \"tagName\":\n                    break;\n                case \"text\":\n                    res.textContent = v + \"\";\n                    break;\n                case \"class\":\n                    res.className = Array.isArray(v) ? v.filter(x => !!x).join(\" \") : v + \"\";\n                    break;\n                default:\n                    res.setAttribute(k, v + \"\");\n                    break;\n            }\n        }\n        if (children) {\n            for (let child of children) {\n                if (!child) {\n                    continue;\n                }\n                res.appendChild(child instanceof HTMLElement ? child : (0, control_1.isControl)(child) ? child.element : tag(child));\n            }\n        }\n        return res;\n    }\n    exports.tag = tag;\n    function toHtmlTag(taggable) {\n        return !taggable ? null\n            : taggable instanceof HTMLElement ? taggable\n                : (0, control_1.isControl)(taggable) ? taggable.element\n                    : tag(taggable);\n    }\n    exports.toHtmlTag = toHtmlTag;\n    function isInDOM(node) {\n        do {\n            if (node === document.body) {\n                return true;\n            }\n            if (!node.parentNode) {\n                return false;\n            }\n            node = node.parentNode;\n        } while (true);\n    }\n    exports.isInDOM = isInDOM;\n}\n"],["/client/utils/drag","function (exports, require) {\n    function addDragListeners(params) {\n        let pointerIsLocked = false;\n        let prevX = 0, prevY = 0;\n        function onTouchMove(evt) {\n            let firstTouch = evt.touches[0];\n            if (!firstTouch) {\n                onTouchEnd();\n                return;\n            }\n            params.onDrag({\n                x: firstTouch.clientX,\n                y: firstTouch.clientY,\n                dx: prevX - firstTouch.clientX,\n                dy: prevY - firstTouch.clientY,\n                source: \"touch\"\n            });\n            prevX = firstTouch.clientX;\n            prevY = firstTouch.clientY;\n        }\n        function onMouseMove(evt) {\n            if (pointerIsLocked) {\n                params.onDrag({\n                    x: evt.clientX,\n                    y: evt.clientX,\n                    dx: -evt.movementX,\n                    dy: -evt.movementY,\n                    source: \"pointer\"\n                });\n            }\n            else {\n                params.onDrag({\n                    x: evt.clientX,\n                    y: evt.clientX,\n                    dx: prevX - evt.clientX,\n                    dy: prevY - evt.clientY,\n                    source: \"pointer\"\n                });\n                prevX = evt.clientX;\n                prevY = evt.clientY;\n            }\n        }\n        function onTouchEnd() {\n            window.removeEventListener(\"touchmove\", onTouchMove);\n            window.removeEventListener(\"touchend\", onTouchEnd);\n            params.onDragEnd && params.onDragEnd();\n        }\n        function onMouseUp() {\n            window.removeEventListener(\"mousemove\", onMouseMove);\n            window.removeEventListener(\"mouseup\", onMouseUp);\n            if (pointerIsLocked) {\n                document.exitPointerLock();\n            }\n            params.onDragEnd && params.onDragEnd();\n        }\n        function installDragListeners(evt) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            params.onDragStart && params.onDragStart();\n            if (evt instanceof TouchEvent) {\n                let firstTouch = evt.touches[0];\n                prevX = firstTouch.clientX;\n                prevY = firstTouch.clientY;\n                window.addEventListener(\"touchmove\", onTouchMove, { passive: true });\n                window.addEventListener(\"touchend\", onTouchEnd, { passive: true });\n            }\n            else {\n                prevX = evt.clientX;\n                prevY = evt.clientY;\n                window.addEventListener(\"mousemove\", onMouseMove, { passive: true });\n                window.addEventListener(\"mouseup\", onMouseUp, { passive: true });\n            }\n        }\n        params.element.addEventListener(\"mousedown\", evt => {\n            let expectedButton = params.rightMouseButton ? 2 : 0;\n            if (evt.button !== expectedButton) {\n                return;\n            }\n            if (params.lockPointer && params.element instanceof HTMLCanvasElement) {\n                pointerIsLocked = lockPointer(params.element);\n            }\n            installDragListeners(evt);\n        });\n        params.element.addEventListener(\"touchstart\", evt => {\n            installDragListeners(evt);\n        }, { passive: true });\n        if (params.rightMouseButton) {\n            params.element.addEventListener(\"contextmenu\", evt => {\n                evt.preventDefault();\n                evt.stopPropagation();\n            });\n        }\n        if (params.lockPointer) {\n            document.addEventListener(\"pointerlockchange\", () => {\n                pointerIsLocked = document.pointerLockElement === params.element;\n            }, { capture: false, passive: true });\n        }\n    }\n    exports.addDragListeners = addDragListeners;\n    function lockPointer(canvas) {\n        if (!canvas.requestPointerLock) {\n            return false;\n        }\n        canvas.requestPointerLock();\n        return true;\n    }\n}\n"],["/client/utils/graphic_utils","function (exports, require) {\n    function isWebGLAvailable(version) {\n        try {\n            const canvas = document.createElement(\"canvas\");\n            if (version === 1) {\n                return !!(window.WebGLRenderingContext && (canvas.getContext(\"webgl\") || canvas.getContext('experimental-webgl')));\n            }\n            else {\n                return !!(window.WebGL2RenderingContext && canvas.getContext(\"webgl2\"));\n            }\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    exports.isWebGLAvailable = isWebGLAvailable;\n    function getWebglErrorElement(version) {\n        const names = {\n            1: \"WebGL\",\n            2: \"WebGL 2\"\n        };\n        const contexts = {\n            1: window.WebGLRenderingContext,\n            2: window.WebGL2RenderingContext\n        };\n        const result = document.createElement(\"div\");\n        result.className = \"webgl-error-message\";\n        let target = contexts[version] ? \"graphics card\" : \"browser\";\n        result.textContent = `Your ${target} does not seem to support `;\n        let link = document.createElement(\"a\");\n        link.setAttribute(\"href\", \"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\");\n        link.textContent = names[version];\n        result.appendChild(link);\n        return result;\n    }\n    exports.getWebglErrorElement = getWebglErrorElement;\n    function raf(handler) {\n        let lastInvokeTime = Date.now();\n        let stopped = false;\n        let wrappedHandler = () => {\n            if (stopped) {\n                return;\n            }\n            requestAnimationFrame(wrappedHandler);\n            let newNow = Date.now();\n            let diff = newNow - lastInvokeTime;\n            lastInvokeTime = newNow;\n            handler(diff);\n        };\n        requestAnimationFrame(wrappedHandler);\n        return () => stopped = true;\n    }\n    exports.raf = raf;\n}\n"],["/client/utils/number_utils","function (exports, require) {\n    function toFixedNoTrail(v, positions) {\n        return v.toFixed(positions).replace(/\\.?0+$/, \"\");\n    }\n    exports.toFixedNoTrail = toFixedNoTrail;\n}\n"],["/client/utils/three_global_pos_to_local","function (exports, require) {\n    function movePositionToLocal(position, parent) {\n        if (parent.parent) {\n            movePositionToLocal(position, parent.parent);\n        }\n        position.x -= parent.position.x;\n        position.y -= parent.position.y;\n        position.z -= parent.position.z;\n        let rot = parent.rotation.clone();\n        rot.x = -rot.x;\n        rot.y = -rot.y;\n        rot.z = -rot.z;\n        position.applyEuler(rot);\n    }\n    exports.movePositionToLocal = movePositionToLocal;\n}\n"],["/client/utils/three_text_render",["/client/threejs_decl"],"function (exports, require, threejs_decl_1) {\n    function renderTextToTexture(text, height, marginX, marginY, fgColor, bgColor) {\n        let canvas = document.createElement(\"canvas\");\n        let context2d = canvas.getContext(\"2d\");\n        if (!context2d) {\n            throw new Error(\"No context 2d, cannot render text.\");\n        }\n        context2d.font = height + \"px sans-serif\";\n        let width = context2d.measureText(text).width;\n        canvas.width = width + (marginX * 2);\n        canvas.height = height + (marginY * 2);\n        context2d.fillStyle = bgColor;\n        context2d.fillRect(0, 0, canvas.width, canvas.height);\n        context2d.textAlign = \"center\";\n        context2d.textBaseline = \"middle\";\n        context2d.fillStyle = fgColor;\n        context2d.font = height + \"px sans-serif\";\n        context2d.fillText(text, canvas.width / 2, canvas.height / 2);\n        let texture = new threejs_decl_1.THREE.Texture(canvas);\n        texture.minFilter = threejs_decl_1.THREE.LinearFilter;\n        texture.needsUpdate = true;\n        return {\n            texture,\n            width: canvas.width,\n            height: canvas.height\n        };\n    }\n    exports.renderTextToTexture = renderTextToTexture;\n}\n"],["/client/utils/watch_node_inserted_removed","function (exports, require) {\n    let observer = null;\n    let removableNodes = new WeakMap();\n    let insertableNodes = new WeakMap();\n    function collectHandleableNodesRecursive(node, map, destination) {\n        if (map.has(node)) {\n            destination.add(node);\n        }\n        node.childNodes.forEach(child => collectHandleableNodesRecursive(child, map, destination));\n    }\n    function dropOrInvokeHandleableNodesRecursive(node, map, oppositeNodes) {\n        let handlers = map.get(node);\n        if (handlers) {\n            if (oppositeNodes.has(node)) {\n                oppositeNodes.delete(node);\n            }\n            else {\n                map.delete(node);\n                for (let i = 0; i < handlers.length; i++) {\n                    handlers[i]();\n                }\n            }\n        }\n        node.childNodes.forEach(child => dropOrInvokeHandleableNodesRecursive(child, map, oppositeNodes));\n    }\n    function doWithRecords(records) {\n        let addedNodes = new Set();\n        for (let i = 0; i < records.length; i++) {\n            let record = records[i];\n            for (let j = 0; j < record.addedNodes.length; j++) {\n                collectHandleableNodesRecursive(record.addedNodes[j], insertableNodes, addedNodes);\n            }\n        }\n        for (let i = 0; i < records.length; i++) {\n            let record = records[i];\n            for (let j = 0; j < record.removedNodes.length; j++) {\n                dropOrInvokeHandleableNodesRecursive(record.removedNodes[j], removableNodes, addedNodes);\n            }\n        }\n        addedNodes.forEach(node => {\n            let handlers = insertableNodes.get(node);\n            if (handlers) {\n                insertableNodes.delete(node);\n                for (let i = 0; i < handlers.length; i++) {\n                    handlers[i]();\n                }\n            }\n        });\n    }\n    function init() {\n        if (observer) {\n            return;\n        }\n        observer = new MutationObserver(doWithRecords);\n        observer.observe(document.body, { childList: true, subtree: true });\n    }\n    function addHandlerToMap(map, node, handler) {\n        {\n            let arr = map.get(node);\n            if (arr) {\n                arr.push(handler);\n            }\n            else {\n                map.set(node, [handler]);\n            }\n        }\n        return () => {\n            let arr = map.get(node);\n            if (!arr) {\n                return;\n            }\n            arr = arr.filter(x => x !== handler);\n            if (arr.length > 0) {\n                map.set(node, arr);\n            }\n            else {\n                map.delete(node);\n            }\n        };\n    }\n    function watchNodeRemoved(node, handler) {\n        init();\n        return addHandlerToMap(removableNodes, node, handler);\n    }\n    exports.watchNodeRemoved = watchNodeRemoved;\n    function watchNodeInserted(node, handler) {\n        init();\n        return addHandlerToMap(insertableNodes, node, handler);\n    }\n    exports.watchNodeInserted = watchNodeInserted;\n}\n"],["/client/utils/watch_node_resized","function (exports, require) {\n    function watchNodeResized(el, handler) {\n        let requestAnimationFrame = window.requestAnimationFrame || ((cb) => window.setTimeout(cb, ~~(1000 / 60)));\n        let style = \"position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;\";\n        let styleChild = \"position: absolute; left: 0; top: 0; transition: 0s;\";\n        let wrap = document.createElement(\"div\");\n        wrap.classList.add(\"resize-sensor\");\n        wrap.style.cssText = style;\n        let expandWrap = document.createElement(\"div\");\n        expandWrap.style.cssText = style;\n        let expandChild = document.createElement(\"div\");\n        expandChild.style.cssText = styleChild;\n        expandWrap.appendChild(expandChild);\n        wrap.appendChild(expandWrap);\n        let shrinkWrap = document.createElement(\"div\");\n        shrinkWrap.style.cssText = style;\n        let shrinkChild = document.createElement(\"div\");\n        shrinkChild.style.cssText = styleChild + \"width: 200%; height: 200%;\";\n        shrinkWrap.appendChild(shrinkChild);\n        wrap.appendChild(shrinkWrap);\n        el.appendChild(wrap);\n        if (wrap.offsetParent !== el) {\n            el.style.position = \"relative\";\n        }\n        let dirty, rafId, newWidth, newHeight;\n        let lastWidth = el.offsetWidth;\n        let lastHeight = el.offsetHeight;\n        let reset = () => {\n            expandChild.style.width = \"100000px\";\n            expandChild.style.height = \"100000px\";\n            expandWrap.scrollLeft = 100000;\n            expandWrap.scrollTop = 100000;\n            shrinkWrap.scrollLeft = 100000;\n            shrinkWrap.scrollTop = 100000;\n        };\n        reset();\n        let onScroll = () => {\n            newWidth = el.offsetWidth;\n            newHeight = el.offsetHeight;\n            dirty = newWidth != lastWidth || newHeight != lastHeight;\n            if (dirty && !rafId) {\n                rafId = requestAnimationFrame(() => {\n                    rafId = 0;\n                    if (!dirty)\n                        return;\n                    lastWidth = newWidth;\n                    lastHeight = newHeight;\n                    handler();\n                });\n            }\n            reset();\n        };\n        expandWrap.addEventListener(\"scroll\", onScroll, { passive: true });\n        shrinkWrap.addEventListener(\"scroll\", onScroll, { passive: true });\n        return () => {\n            wrap.remove();\n            expandWrap.removeEventListener(\"scroll\", onScroll);\n            shrinkWrap.removeEventListener(\"scroll\", onScroll);\n        };\n    }\n    exports.watchNodeResized = watchNodeResized;\n}\n"],["/common/utils","function (exports, require) {\n    function logError(a, b) {\n        outputError(\"error\", a, b);\n    }\n    exports.logError = logError;\n    function logWarn(a, b) {\n        outputError(\"warn\", a, b);\n    }\n    exports.logWarn = logWarn;\n    function outputError(type, a, b) {\n        let err = typeof (a) === \"string\" ? b : a;\n        let pretext = typeof (a) === \"string\" ? a : \"\";\n        let errText;\n        if (err instanceof Error) {\n            errText = (err.stack || err.message || err) + \"\";\n        }\n        else {\n            errText = err + \"\";\n        }\n        console[type](pretext + errText);\n    }\n    function isPathInsidePath(innerPath, outerPath) {\n        let startsWith = innerPath.indexOf(outerPath) === 0;\n        if (!startsWith) {\n            return false;\n        }\n        let nextChar = innerPath.length === outerPath.length ? '' : innerPath.charAt(outerPath.length);\n        let hasPathTerminator = nextChar === '/' || nextChar === '\\\\' || nextChar === '';\n        return hasPathTerminator;\n    }\n    exports.isPathInsidePath = isPathInsidePath;\n    function randomNumberString() {\n        return Math.floor(Math.random() * 0xffffffff) + \"\";\n    }\n    exports.randomNumberString = randomNumberString;\n    function randomUniqId(idObject) {\n        let id;\n        do {\n            id = randomNumberString();\n        } while (id in idObject);\n        return id;\n    }\n    exports.randomUniqId = randomUniqId;\n    function deepEquals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (typeof (a) !== typeof (b)) {\n            return false;\n        }\n        if (typeof (a) === \"object\" && typeof (b) === \"object\" && a && b) {\n            if (Array.isArray(a) || Array.isArray(b)) {\n                if (!Array.isArray(a) || !Array.isArray(b)) {\n                    return false;\n                }\n                if (a.length !== b.length) {\n                    return false;\n                }\n                for (let i = 0; i < a.length; i++) {\n                    if (!deepEquals(a[i], b[i])) {\n                        return false;\n                    }\n                }\n            }\n            else {\n                for (let k in a) {\n                    if (!(k in b) || !deepEquals(a[k], b[k])) {\n                        return false;\n                    }\n                }\n                for (let k in b) {\n                    if (!(k in a)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    exports.deepEquals = deepEquals;\n}\n"]]
,
{"entryPoint":{"module":"/client/client_entrypoint","function":"main"}},eval);